//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 ./find/Find.g 2012-12-27 13:45:13

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  find 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class FindParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "DEPTH", "EQ", "ESC", "HEX_DIGIT", "INAME", "IREGEX", "LPAREN", "NAME", "NOT", "OR", "PATH", "REGEX", "RPAREN", "SIZE", "STRING_LITERAL", "TYPE", "UNQOTED_LITERAL", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int DEPTH=5;
	public const int EQ=6;
	public const int ESC=7;
	public const int HEX_DIGIT=8;
	public const int INAME=9;
	public const int IREGEX=10;
	public const int LPAREN=11;
	public const int NAME=12;
	public const int NOT=13;
	public const int OR=14;
	public const int PATH=15;
	public const int REGEX=16;
	public const int RPAREN=17;
	public const int SIZE=18;
	public const int STRING_LITERAL=19;
	public const int TYPE=20;
	public const int UNQOTED_LITERAL=21;
	public const int WS=22;

	public FindParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public FindParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return FindParser.tokenNames; } }
	public override string GrammarFileName { get { return "./find/Find.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_commandline();
	partial void LeaveRule_commandline();

	// $ANTLR start "commandline"
	// ./find/Find.g:12:1: commandline : ( expr )* ;
	[GrammarRule("commandline")]
	private AstParserRuleReturnScope<CommonTree, IToken> commandline()
	{
		EnterRule_commandline();
		EnterRule("commandline", 1);
		TraceIn("commandline", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> expr1 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "commandline");
		DebugLocation(12, 1);
		try
		{
			// ./find/Find.g:13:2: ( ( expr )* )
			DebugEnterAlt(1);
			// ./find/Find.g:13:3: ( expr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(13, 3);
			// ./find/Find.g:13:3: ( expr )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==DEPTH||(LA1_0>=INAME && LA1_0<=NOT)||(LA1_0>=PATH && LA1_0<=REGEX)||LA1_0==SIZE||LA1_0==TYPE))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:13:3: expr
					{
					DebugLocation(13, 3);
					PushFollow(Follow._expr_in_commandline66);
					expr1=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, expr1.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("commandline", 1);
			LeaveRule("commandline", 1);
			LeaveRule_commandline();
		}
		DebugLocation(14, 1);
		} finally { DebugExitRule(GrammarFileName, "commandline"); }
		return retval;

	}
	// $ANTLR end "commandline"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// ./find/Find.g:15:1: expr : ( paren_expr | or_expr );
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> paren_expr2 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> or_expr3 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(15, 1);
		try
		{
			// ./find/Find.g:16:2: ( paren_expr | or_expr )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==LPAREN))
			{
				alt2 = 1;
			}
			else if ((LA2_0==DEPTH||(LA2_0>=INAME && LA2_0<=IREGEX)||(LA2_0>=NAME && LA2_0<=NOT)||(LA2_0>=PATH && LA2_0<=REGEX)||LA2_0==SIZE||LA2_0==TYPE))
			{
				alt2 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:16:4: paren_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(16, 4);
				PushFollow(Follow._paren_expr_in_expr77);
				paren_expr2=paren_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, paren_expr2.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:17:4: or_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(17, 4);
				PushFollow(Follow._or_expr_in_expr82);
				or_expr3=or_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, or_expr3.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(18, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_paren_expr();
	partial void LeaveRule_paren_expr();

	// $ANTLR start "paren_expr"
	// ./find/Find.g:20:1: paren_expr : LPAREN ^ ( WS )? ( or_expr )* ( WS )? RPAREN ;
	[GrammarRule("paren_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> paren_expr()
	{
		EnterRule_paren_expr();
		EnterRule("paren_expr", 3);
		TraceIn("paren_expr", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN4 = default(IToken);
		IToken WS5 = default(IToken);
		IToken WS7 = default(IToken);
		IToken RPAREN8 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> or_expr6 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN4_tree = default(CommonTree);
		CommonTree WS5_tree = default(CommonTree);
		CommonTree WS7_tree = default(CommonTree);
		CommonTree RPAREN8_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "paren_expr");
		DebugLocation(20, 34);
		try
		{
			// ./find/Find.g:21:2: ( LPAREN ^ ( WS )? ( or_expr )* ( WS )? RPAREN )
			DebugEnterAlt(1);
			// ./find/Find.g:21:4: LPAREN ^ ( WS )? ( or_expr )* ( WS )? RPAREN
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(21, 10);
			LPAREN4=(IToken)Match(input,LPAREN,Follow._LPAREN_in_paren_expr93); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN4_tree = (CommonTree)adaptor.Create(LPAREN4);
			root_0 = (CommonTree)adaptor.BecomeRoot(LPAREN4_tree, root_0);
			}
			DebugLocation(21, 12);
			// ./find/Find.g:21:12: ( WS )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==WS))
			{
				int LA3_1 = input.LA(2);

				if ((EvaluatePredicate(synpred3_Find_fragment)))
				{
					alt3 = 1;
				}
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:21:12: WS
				{
				DebugLocation(21, 12);
				WS5=(IToken)Match(input,WS,Follow._WS_in_paren_expr96); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WS5_tree = (CommonTree)adaptor.Create(WS5);
				adaptor.AddChild(root_0, WS5_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(21, 16);
			// ./find/Find.g:21:16: ( or_expr )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==DEPTH||(LA4_0>=INAME && LA4_0<=IREGEX)||(LA4_0>=NAME && LA4_0<=NOT)||(LA4_0>=PATH && LA4_0<=REGEX)||LA4_0==SIZE||LA4_0==TYPE))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:21:16: or_expr
					{
					DebugLocation(21, 16);
					PushFollow(Follow._or_expr_in_paren_expr99);
					or_expr6=or_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, or_expr6.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(21, 25);
			// ./find/Find.g:21:25: ( WS )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==WS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:21:25: WS
				{
				DebugLocation(21, 25);
				WS7=(IToken)Match(input,WS,Follow._WS_in_paren_expr102); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WS7_tree = (CommonTree)adaptor.Create(WS7);
				adaptor.AddChild(root_0, WS7_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(21, 29);
			RPAREN8=(IToken)Match(input,RPAREN,Follow._RPAREN_in_paren_expr105); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RPAREN8_tree = (CommonTree)adaptor.Create(RPAREN8);
			adaptor.AddChild(root_0, RPAREN8_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("paren_expr", 3);
			LeaveRule("paren_expr", 3);
			LeaveRule_paren_expr();
		}
		DebugLocation(21, 34);
		} finally { DebugExitRule(GrammarFileName, "paren_expr"); }
		return retval;

	}
	// $ANTLR end "paren_expr"

	partial void EnterRule_or_expr();
	partial void LeaveRule_or_expr();

	// $ANTLR start "or_expr"
	// ./find/Find.g:22:1: or_expr : and_expr ( ( WS )? OR ^ ( WS )? and_expr )* ;
	[GrammarRule("or_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> or_expr()
	{
		EnterRule_or_expr();
		EnterRule("or_expr", 4);
		TraceIn("or_expr", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS10 = default(IToken);
		IToken OR11 = default(IToken);
		IToken WS12 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> and_expr9 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> and_expr13 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WS10_tree = default(CommonTree);
		CommonTree OR11_tree = default(CommonTree);
		CommonTree WS12_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "or_expr");
		DebugLocation(22, 35);
		try
		{
			// ./find/Find.g:23:2: ( and_expr ( ( WS )? OR ^ ( WS )? and_expr )* )
			DebugEnterAlt(1);
			// ./find/Find.g:23:4: and_expr ( ( WS )? OR ^ ( WS )? and_expr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(23, 4);
			PushFollow(Follow._and_expr_in_or_expr113);
			and_expr9=and_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, and_expr9.Tree);
			DebugLocation(23, 13);
			// ./find/Find.g:23:13: ( ( WS )? OR ^ ( WS )? and_expr )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==WS))
				{
					int LA8_2 = input.LA(2);

					if ((LA8_2==OR))
					{
						alt8 = 1;
					}


				}
				else if ((LA8_0==OR))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:23:14: ( WS )? OR ^ ( WS )? and_expr
					{
					DebugLocation(23, 14);
					// ./find/Find.g:23:14: ( WS )?
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if ((LA6_0==WS))
					{
						alt6 = 1;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:23:14: WS
						{
						DebugLocation(23, 14);
						WS10=(IToken)Match(input,WS,Follow._WS_in_or_expr116); if (state.failed) return retval;
						if (state.backtracking == 0) {
						WS10_tree = (CommonTree)adaptor.Create(WS10);
						adaptor.AddChild(root_0, WS10_tree);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(6); }

					DebugLocation(23, 20);
					OR11=(IToken)Match(input,OR,Follow._OR_in_or_expr119); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR11_tree = (CommonTree)adaptor.Create(OR11);
					root_0 = (CommonTree)adaptor.BecomeRoot(OR11_tree, root_0);
					}
					DebugLocation(23, 22);
					// ./find/Find.g:23:22: ( WS )?
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==WS))
					{
						alt7 = 1;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:23:22: WS
						{
						DebugLocation(23, 22);
						WS12=(IToken)Match(input,WS,Follow._WS_in_or_expr122); if (state.failed) return retval;
						if (state.backtracking == 0) {
						WS12_tree = (CommonTree)adaptor.Create(WS12);
						adaptor.AddChild(root_0, WS12_tree);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(23, 26);
					PushFollow(Follow._and_expr_in_or_expr125);
					and_expr13=and_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, and_expr13.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("or_expr", 4);
			LeaveRule("or_expr", 4);
			LeaveRule_or_expr();
		}
		DebugLocation(23, 35);
		} finally { DebugExitRule(GrammarFileName, "or_expr"); }
		return retval;

	}
	// $ANTLR end "or_expr"

	partial void EnterRule_and_expr();
	partial void LeaveRule_and_expr();

	// $ANTLR start "and_expr"
	// ./find/Find.g:24:1: and_expr : eql_expr ( ( WS )? AND ^ ( WS )? eql_expr )* ;
	[GrammarRule("and_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> and_expr()
	{
		EnterRule_and_expr();
		EnterRule("and_expr", 5);
		TraceIn("and_expr", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WS15 = default(IToken);
		IToken AND16 = default(IToken);
		IToken WS17 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> eql_expr14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> eql_expr18 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WS15_tree = default(CommonTree);
		CommonTree AND16_tree = default(CommonTree);
		CommonTree WS17_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "and_expr");
		DebugLocation(24, 36);
		try
		{
			// ./find/Find.g:25:2: ( eql_expr ( ( WS )? AND ^ ( WS )? eql_expr )* )
			DebugEnterAlt(1);
			// ./find/Find.g:25:4: eql_expr ( ( WS )? AND ^ ( WS )? eql_expr )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(25, 4);
			PushFollow(Follow._eql_expr_in_and_expr135);
			eql_expr14=eql_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, eql_expr14.Tree);
			DebugLocation(25, 13);
			// ./find/Find.g:25:13: ( ( WS )? AND ^ ( WS )? eql_expr )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==WS))
				{
					int LA11_1 = input.LA(2);

					if ((LA11_1==AND))
					{
						alt11 = 1;
					}


				}
				else if ((LA11_0==AND))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:25:14: ( WS )? AND ^ ( WS )? eql_expr
					{
					DebugLocation(25, 14);
					// ./find/Find.g:25:14: ( WS )?
					int alt9=2;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if ((LA9_0==WS))
					{
						alt9 = 1;
					}
					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:25:14: WS
						{
						DebugLocation(25, 14);
						WS15=(IToken)Match(input,WS,Follow._WS_in_and_expr138); if (state.failed) return retval;
						if (state.backtracking == 0) {
						WS15_tree = (CommonTree)adaptor.Create(WS15);
						adaptor.AddChild(root_0, WS15_tree);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(25, 21);
					AND16=(IToken)Match(input,AND,Follow._AND_in_and_expr141); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND16_tree = (CommonTree)adaptor.Create(AND16);
					root_0 = (CommonTree)adaptor.BecomeRoot(AND16_tree, root_0);
					}
					DebugLocation(25, 23);
					// ./find/Find.g:25:23: ( WS )?
					int alt10=2;
					try { DebugEnterSubRule(10);
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==WS))
					{
						alt10 = 1;
					}
					} finally { DebugExitDecision(10); }
					switch (alt10)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:25:23: WS
						{
						DebugLocation(25, 23);
						WS17=(IToken)Match(input,WS,Follow._WS_in_and_expr144); if (state.failed) return retval;
						if (state.backtracking == 0) {
						WS17_tree = (CommonTree)adaptor.Create(WS17);
						adaptor.AddChild(root_0, WS17_tree);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(10); }

					DebugLocation(25, 27);
					PushFollow(Follow._eql_expr_in_and_expr147);
					eql_expr18=eql_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, eql_expr18.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_expr", 5);
			LeaveRule("and_expr", 5);
			LeaveRule_and_expr();
		}
		DebugLocation(25, 36);
		} finally { DebugExitRule(GrammarFileName, "and_expr"); }
		return retval;

	}
	// $ANTLR end "and_expr"

	partial void EnterRule_eql_expr();
	partial void LeaveRule_eql_expr();

	// $ANTLR start "eql_expr"
	// ./find/Find.g:26:1: eql_expr : ( not_expr | argument );
	[GrammarRule("eql_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> eql_expr()
	{
		EnterRule_eql_expr();
		EnterRule("eql_expr", 6);
		TraceIn("eql_expr", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> not_expr19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> argument20 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "eql_expr");
		DebugLocation(26, 11);
		try
		{
			// ./find/Find.g:27:2: ( not_expr | argument )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==NOT))
			{
				alt12 = 1;
			}
			else if ((LA12_0==DEPTH||(LA12_0>=INAME && LA12_0<=IREGEX)||LA12_0==NAME||(LA12_0>=PATH && LA12_0<=REGEX)||LA12_0==SIZE||LA12_0==TYPE))
			{
				alt12 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:27:4: not_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(27, 4);
				PushFollow(Follow._not_expr_in_eql_expr157);
				not_expr19=not_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, not_expr19.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:28:4: argument
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(28, 4);
				PushFollow(Follow._argument_in_eql_expr162);
				argument20=argument();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, argument20.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("eql_expr", 6);
			LeaveRule("eql_expr", 6);
			LeaveRule_eql_expr();
		}
		DebugLocation(28, 11);
		} finally { DebugExitRule(GrammarFileName, "eql_expr"); }
		return retval;

	}
	// $ANTLR end "eql_expr"

	partial void EnterRule_not_expr();
	partial void LeaveRule_not_expr();

	// $ANTLR start "not_expr"
	// ./find/Find.g:29:1: not_expr : ( NOT ^ ( WS )? argument | NOT ^ ( WS )? paren_expr );
	[GrammarRule("not_expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> not_expr()
	{
		EnterRule_not_expr();
		EnterRule("not_expr", 7);
		TraceIn("not_expr", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NOT21 = default(IToken);
		IToken WS22 = default(IToken);
		IToken NOT24 = default(IToken);
		IToken WS25 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> argument23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> paren_expr26 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NOT21_tree = default(CommonTree);
		CommonTree WS22_tree = default(CommonTree);
		CommonTree NOT24_tree = default(CommonTree);
		CommonTree WS25_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "not_expr");
		DebugLocation(29, 21);
		try
		{
			// ./find/Find.g:30:2: ( NOT ^ ( WS )? argument | NOT ^ ( WS )? paren_expr )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==NOT))
			{
				switch (input.LA(2))
				{
				case WS:
					{
					int LA15_2 = input.LA(3);

					if ((LA15_2==DEPTH||(LA15_2>=INAME && LA15_2<=IREGEX)||LA15_2==NAME||(LA15_2>=PATH && LA15_2<=REGEX)||LA15_2==SIZE||LA15_2==TYPE))
					{
						alt15 = 1;
					}
					else if ((LA15_2==LPAREN))
					{
						alt15 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case DEPTH:
				case INAME:
				case IREGEX:
				case NAME:
				case PATH:
				case REGEX:
				case SIZE:
				case TYPE:
					{
					alt15 = 1;
					}
					break;
				case LPAREN:
					{
					alt15 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 15, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:30:3: NOT ^ ( WS )? argument
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(30, 6);
				NOT21=(IToken)Match(input,NOT,Follow._NOT_in_not_expr169); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT21_tree = (CommonTree)adaptor.Create(NOT21);
				root_0 = (CommonTree)adaptor.BecomeRoot(NOT21_tree, root_0);
				}
				DebugLocation(30, 8);
				// ./find/Find.g:30:8: ( WS )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==WS))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:30:8: WS
					{
					DebugLocation(30, 8);
					WS22=(IToken)Match(input,WS,Follow._WS_in_not_expr172); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS22_tree = (CommonTree)adaptor.Create(WS22);
					adaptor.AddChild(root_0, WS22_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(30, 12);
				PushFollow(Follow._argument_in_not_expr175);
				argument23=argument();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, argument23.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:31:3: NOT ^ ( WS )? paren_expr
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(31, 6);
				NOT24=(IToken)Match(input,NOT,Follow._NOT_in_not_expr179); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT24_tree = (CommonTree)adaptor.Create(NOT24);
				root_0 = (CommonTree)adaptor.BecomeRoot(NOT24_tree, root_0);
				}
				DebugLocation(31, 8);
				// ./find/Find.g:31:8: ( WS )?
				int alt14=2;
				try { DebugEnterSubRule(14);
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==WS))
				{
					alt14 = 1;
				}
				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:31:8: WS
					{
					DebugLocation(31, 8);
					WS25=(IToken)Match(input,WS,Follow._WS_in_not_expr182); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS25_tree = (CommonTree)adaptor.Create(WS25);
					adaptor.AddChild(root_0, WS25_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(14); }

				DebugLocation(31, 12);
				PushFollow(Follow._paren_expr_in_not_expr185);
				paren_expr26=paren_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, paren_expr26.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("not_expr", 7);
			LeaveRule("not_expr", 7);
			LeaveRule_not_expr();
		}
		DebugLocation(31, 21);
		} finally { DebugExitRule(GrammarFileName, "not_expr"); }
		return retval;

	}
	// $ANTLR end "not_expr"

	partial void EnterRule_argument();
	partial void LeaveRule_argument();

	// $ANTLR start "argument"
	// ./find/Find.g:33:1: argument : ( NAME ^ ( WS )? EQ ( WS )? value | INAME ^ ( WS )? EQ ( WS )? value | REGEX ^ ( WS )? EQ ( WS )? value | IREGEX ^ ( WS )? EQ ( WS )? value | TYPE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | SIZE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | DEPTH ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | PATH ^ ( WS )? EQ ( WS )? value );
	[GrammarRule("argument")]
	private AstParserRuleReturnScope<CommonTree, IToken> argument()
	{
		EnterRule_argument();
		EnterRule("argument", 8);
		TraceIn("argument", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NAME27 = default(IToken);
		IToken WS28 = default(IToken);
		IToken EQ29 = default(IToken);
		IToken WS30 = default(IToken);
		IToken INAME32 = default(IToken);
		IToken WS33 = default(IToken);
		IToken EQ34 = default(IToken);
		IToken WS35 = default(IToken);
		IToken REGEX37 = default(IToken);
		IToken WS38 = default(IToken);
		IToken EQ39 = default(IToken);
		IToken WS40 = default(IToken);
		IToken IREGEX42 = default(IToken);
		IToken WS43 = default(IToken);
		IToken EQ44 = default(IToken);
		IToken WS45 = default(IToken);
		IToken TYPE47 = default(IToken);
		IToken WS48 = default(IToken);
		IToken EQ49 = default(IToken);
		IToken WS50 = default(IToken);
		IToken UNQOTED_LITERAL51 = default(IToken);
		IToken SIZE52 = default(IToken);
		IToken WS53 = default(IToken);
		IToken EQ54 = default(IToken);
		IToken WS55 = default(IToken);
		IToken UNQOTED_LITERAL56 = default(IToken);
		IToken DEPTH57 = default(IToken);
		IToken WS58 = default(IToken);
		IToken EQ59 = default(IToken);
		IToken WS60 = default(IToken);
		IToken UNQOTED_LITERAL61 = default(IToken);
		IToken PATH62 = default(IToken);
		IToken WS63 = default(IToken);
		IToken EQ64 = default(IToken);
		IToken WS65 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> value31 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> value66 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NAME27_tree = default(CommonTree);
		CommonTree WS28_tree = default(CommonTree);
		CommonTree EQ29_tree = default(CommonTree);
		CommonTree WS30_tree = default(CommonTree);
		CommonTree INAME32_tree = default(CommonTree);
		CommonTree WS33_tree = default(CommonTree);
		CommonTree EQ34_tree = default(CommonTree);
		CommonTree WS35_tree = default(CommonTree);
		CommonTree REGEX37_tree = default(CommonTree);
		CommonTree WS38_tree = default(CommonTree);
		CommonTree EQ39_tree = default(CommonTree);
		CommonTree WS40_tree = default(CommonTree);
		CommonTree IREGEX42_tree = default(CommonTree);
		CommonTree WS43_tree = default(CommonTree);
		CommonTree EQ44_tree = default(CommonTree);
		CommonTree WS45_tree = default(CommonTree);
		CommonTree TYPE47_tree = default(CommonTree);
		CommonTree WS48_tree = default(CommonTree);
		CommonTree EQ49_tree = default(CommonTree);
		CommonTree WS50_tree = default(CommonTree);
		CommonTree UNQOTED_LITERAL51_tree = default(CommonTree);
		CommonTree SIZE52_tree = default(CommonTree);
		CommonTree WS53_tree = default(CommonTree);
		CommonTree EQ54_tree = default(CommonTree);
		CommonTree WS55_tree = default(CommonTree);
		CommonTree UNQOTED_LITERAL56_tree = default(CommonTree);
		CommonTree DEPTH57_tree = default(CommonTree);
		CommonTree WS58_tree = default(CommonTree);
		CommonTree EQ59_tree = default(CommonTree);
		CommonTree WS60_tree = default(CommonTree);
		CommonTree UNQOTED_LITERAL61_tree = default(CommonTree);
		CommonTree PATH62_tree = default(CommonTree);
		CommonTree WS63_tree = default(CommonTree);
		CommonTree EQ64_tree = default(CommonTree);
		CommonTree WS65_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "argument");
		DebugLocation(33, 1);
		try
		{
			// ./find/Find.g:34:2: ( NAME ^ ( WS )? EQ ( WS )? value | INAME ^ ( WS )? EQ ( WS )? value | REGEX ^ ( WS )? EQ ( WS )? value | IREGEX ^ ( WS )? EQ ( WS )? value | TYPE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | SIZE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | DEPTH ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL | PATH ^ ( WS )? EQ ( WS )? value )
			int alt32=8;
			try { DebugEnterDecision(32, false);
			switch (input.LA(1))
			{
			case NAME:
				{
				alt32 = 1;
				}
				break;
			case INAME:
				{
				alt32 = 2;
				}
				break;
			case REGEX:
				{
				alt32 = 3;
				}
				break;
			case IREGEX:
				{
				alt32 = 4;
				}
				break;
			case TYPE:
				{
				alt32 = 5;
				}
				break;
			case SIZE:
				{
				alt32 = 6;
				}
				break;
			case DEPTH:
				{
				alt32 = 7;
				}
				break;
			case PATH:
				{
				alt32 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:34:4: NAME ^ ( WS )? EQ ( WS )? value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(34, 8);
				NAME27=(IToken)Match(input,NAME,Follow._NAME_in_argument194); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NAME27_tree = (CommonTree)adaptor.Create(NAME27);
				root_0 = (CommonTree)adaptor.BecomeRoot(NAME27_tree, root_0);
				}
				DebugLocation(34, 10);
				// ./find/Find.g:34:10: ( WS )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==WS))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:34:10: WS
					{
					DebugLocation(34, 10);
					WS28=(IToken)Match(input,WS,Follow._WS_in_argument197); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS28_tree = (CommonTree)adaptor.Create(WS28);
					adaptor.AddChild(root_0, WS28_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(16); }

				DebugLocation(34, 14);
				EQ29=(IToken)Match(input,EQ,Follow._EQ_in_argument200); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ29_tree = (CommonTree)adaptor.Create(EQ29);
				adaptor.AddChild(root_0, EQ29_tree);
				}
				DebugLocation(34, 17);
				// ./find/Find.g:34:17: ( WS )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0==WS))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:34:17: WS
					{
					DebugLocation(34, 17);
					WS30=(IToken)Match(input,WS,Follow._WS_in_argument202); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS30_tree = (CommonTree)adaptor.Create(WS30);
					adaptor.AddChild(root_0, WS30_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(34, 21);
				PushFollow(Follow._value_in_argument205);
				value31=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value31.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:35:4: INAME ^ ( WS )? EQ ( WS )? value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(35, 9);
				INAME32=(IToken)Match(input,INAME,Follow._INAME_in_argument210); if (state.failed) return retval;
				if (state.backtracking == 0) {
				INAME32_tree = (CommonTree)adaptor.Create(INAME32);
				root_0 = (CommonTree)adaptor.BecomeRoot(INAME32_tree, root_0);
				}
				DebugLocation(35, 11);
				// ./find/Find.g:35:11: ( WS )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==WS))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:35:11: WS
					{
					DebugLocation(35, 11);
					WS33=(IToken)Match(input,WS,Follow._WS_in_argument213); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS33_tree = (CommonTree)adaptor.Create(WS33);
					adaptor.AddChild(root_0, WS33_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(35, 15);
				EQ34=(IToken)Match(input,EQ,Follow._EQ_in_argument216); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ34_tree = (CommonTree)adaptor.Create(EQ34);
				adaptor.AddChild(root_0, EQ34_tree);
				}
				DebugLocation(35, 18);
				// ./find/Find.g:35:18: ( WS )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==WS))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:35:18: WS
					{
					DebugLocation(35, 18);
					WS35=(IToken)Match(input,WS,Follow._WS_in_argument218); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS35_tree = (CommonTree)adaptor.Create(WS35);
					adaptor.AddChild(root_0, WS35_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(19); }

				DebugLocation(35, 22);
				PushFollow(Follow._value_in_argument221);
				value36=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value36.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:36:4: REGEX ^ ( WS )? EQ ( WS )? value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(36, 9);
				REGEX37=(IToken)Match(input,REGEX,Follow._REGEX_in_argument227); if (state.failed) return retval;
				if (state.backtracking == 0) {
				REGEX37_tree = (CommonTree)adaptor.Create(REGEX37);
				root_0 = (CommonTree)adaptor.BecomeRoot(REGEX37_tree, root_0);
				}
				DebugLocation(36, 11);
				// ./find/Find.g:36:11: ( WS )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_0 = input.LA(1);

				if ((LA20_0==WS))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:36:11: WS
					{
					DebugLocation(36, 11);
					WS38=(IToken)Match(input,WS,Follow._WS_in_argument230); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS38_tree = (CommonTree)adaptor.Create(WS38);
					adaptor.AddChild(root_0, WS38_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(20); }

				DebugLocation(36, 15);
				EQ39=(IToken)Match(input,EQ,Follow._EQ_in_argument233); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ39_tree = (CommonTree)adaptor.Create(EQ39);
				adaptor.AddChild(root_0, EQ39_tree);
				}
				DebugLocation(36, 18);
				// ./find/Find.g:36:18: ( WS )?
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==WS))
				{
					alt21 = 1;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:36:18: WS
					{
					DebugLocation(36, 18);
					WS40=(IToken)Match(input,WS,Follow._WS_in_argument235); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS40_tree = (CommonTree)adaptor.Create(WS40);
					adaptor.AddChild(root_0, WS40_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(21); }

				DebugLocation(36, 22);
				PushFollow(Follow._value_in_argument238);
				value41=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value41.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ./find/Find.g:37:4: IREGEX ^ ( WS )? EQ ( WS )? value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(37, 10);
				IREGEX42=(IToken)Match(input,IREGEX,Follow._IREGEX_in_argument244); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IREGEX42_tree = (CommonTree)adaptor.Create(IREGEX42);
				root_0 = (CommonTree)adaptor.BecomeRoot(IREGEX42_tree, root_0);
				}
				DebugLocation(37, 12);
				// ./find/Find.g:37:12: ( WS )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==WS))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:37:12: WS
					{
					DebugLocation(37, 12);
					WS43=(IToken)Match(input,WS,Follow._WS_in_argument247); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS43_tree = (CommonTree)adaptor.Create(WS43);
					adaptor.AddChild(root_0, WS43_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(37, 16);
				EQ44=(IToken)Match(input,EQ,Follow._EQ_in_argument250); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ44_tree = (CommonTree)adaptor.Create(EQ44);
				adaptor.AddChild(root_0, EQ44_tree);
				}
				DebugLocation(37, 19);
				// ./find/Find.g:37:19: ( WS )?
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==WS))
				{
					alt23 = 1;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:37:19: WS
					{
					DebugLocation(37, 19);
					WS45=(IToken)Match(input,WS,Follow._WS_in_argument252); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS45_tree = (CommonTree)adaptor.Create(WS45);
					adaptor.AddChild(root_0, WS45_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(23); }

				DebugLocation(37, 23);
				PushFollow(Follow._value_in_argument255);
				value46=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value46.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ./find/Find.g:38:4: TYPE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(38, 8);
				TYPE47=(IToken)Match(input,TYPE,Follow._TYPE_in_argument262); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TYPE47_tree = (CommonTree)adaptor.Create(TYPE47);
				root_0 = (CommonTree)adaptor.BecomeRoot(TYPE47_tree, root_0);
				}
				DebugLocation(38, 10);
				// ./find/Find.g:38:10: ( WS )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==WS))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:38:10: WS
					{
					DebugLocation(38, 10);
					WS48=(IToken)Match(input,WS,Follow._WS_in_argument265); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS48_tree = (CommonTree)adaptor.Create(WS48);
					adaptor.AddChild(root_0, WS48_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(38, 14);
				EQ49=(IToken)Match(input,EQ,Follow._EQ_in_argument268); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ49_tree = (CommonTree)adaptor.Create(EQ49);
				adaptor.AddChild(root_0, EQ49_tree);
				}
				DebugLocation(38, 17);
				// ./find/Find.g:38:17: ( WS )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==WS))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:38:17: WS
					{
					DebugLocation(38, 17);
					WS50=(IToken)Match(input,WS,Follow._WS_in_argument270); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS50_tree = (CommonTree)adaptor.Create(WS50);
					adaptor.AddChild(root_0, WS50_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(25); }

				DebugLocation(38, 21);
				UNQOTED_LITERAL51=(IToken)Match(input,UNQOTED_LITERAL,Follow._UNQOTED_LITERAL_in_argument273); if (state.failed) return retval;
				if (state.backtracking == 0) {
				UNQOTED_LITERAL51_tree = (CommonTree)adaptor.Create(UNQOTED_LITERAL51);
				adaptor.AddChild(root_0, UNQOTED_LITERAL51_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ./find/Find.g:39:4: SIZE ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(39, 8);
				SIZE52=(IToken)Match(input,SIZE,Follow._SIZE_in_argument279); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SIZE52_tree = (CommonTree)adaptor.Create(SIZE52);
				root_0 = (CommonTree)adaptor.BecomeRoot(SIZE52_tree, root_0);
				}
				DebugLocation(39, 10);
				// ./find/Find.g:39:10: ( WS )?
				int alt26=2;
				try { DebugEnterSubRule(26);
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==WS))
				{
					alt26 = 1;
				}
				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:39:10: WS
					{
					DebugLocation(39, 10);
					WS53=(IToken)Match(input,WS,Follow._WS_in_argument282); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS53_tree = (CommonTree)adaptor.Create(WS53);
					adaptor.AddChild(root_0, WS53_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(26); }

				DebugLocation(39, 14);
				EQ54=(IToken)Match(input,EQ,Follow._EQ_in_argument285); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ54_tree = (CommonTree)adaptor.Create(EQ54);
				adaptor.AddChild(root_0, EQ54_tree);
				}
				DebugLocation(39, 17);
				// ./find/Find.g:39:17: ( WS )?
				int alt27=2;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==WS))
				{
					alt27 = 1;
				}
				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:39:17: WS
					{
					DebugLocation(39, 17);
					WS55=(IToken)Match(input,WS,Follow._WS_in_argument287); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS55_tree = (CommonTree)adaptor.Create(WS55);
					adaptor.AddChild(root_0, WS55_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(27); }

				DebugLocation(39, 21);
				UNQOTED_LITERAL56=(IToken)Match(input,UNQOTED_LITERAL,Follow._UNQOTED_LITERAL_in_argument290); if (state.failed) return retval;
				if (state.backtracking == 0) {
				UNQOTED_LITERAL56_tree = (CommonTree)adaptor.Create(UNQOTED_LITERAL56);
				adaptor.AddChild(root_0, UNQOTED_LITERAL56_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ./find/Find.g:40:4: DEPTH ^ ( WS )? EQ ( WS )? UNQOTED_LITERAL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(40, 9);
				DEPTH57=(IToken)Match(input,DEPTH,Follow._DEPTH_in_argument296); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DEPTH57_tree = (CommonTree)adaptor.Create(DEPTH57);
				root_0 = (CommonTree)adaptor.BecomeRoot(DEPTH57_tree, root_0);
				}
				DebugLocation(40, 11);
				// ./find/Find.g:40:11: ( WS )?
				int alt28=2;
				try { DebugEnterSubRule(28);
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==WS))
				{
					alt28 = 1;
				}
				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:40:11: WS
					{
					DebugLocation(40, 11);
					WS58=(IToken)Match(input,WS,Follow._WS_in_argument299); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS58_tree = (CommonTree)adaptor.Create(WS58);
					adaptor.AddChild(root_0, WS58_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(28); }

				DebugLocation(40, 15);
				EQ59=(IToken)Match(input,EQ,Follow._EQ_in_argument302); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ59_tree = (CommonTree)adaptor.Create(EQ59);
				adaptor.AddChild(root_0, EQ59_tree);
				}
				DebugLocation(40, 18);
				// ./find/Find.g:40:18: ( WS )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==WS))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:40:18: WS
					{
					DebugLocation(40, 18);
					WS60=(IToken)Match(input,WS,Follow._WS_in_argument304); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS60_tree = (CommonTree)adaptor.Create(WS60);
					adaptor.AddChild(root_0, WS60_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(29); }

				DebugLocation(40, 22);
				UNQOTED_LITERAL61=(IToken)Match(input,UNQOTED_LITERAL,Follow._UNQOTED_LITERAL_in_argument307); if (state.failed) return retval;
				if (state.backtracking == 0) {
				UNQOTED_LITERAL61_tree = (CommonTree)adaptor.Create(UNQOTED_LITERAL61);
				adaptor.AddChild(root_0, UNQOTED_LITERAL61_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ./find/Find.g:41:4: PATH ^ ( WS )? EQ ( WS )? value
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(41, 8);
				PATH62=(IToken)Match(input,PATH,Follow._PATH_in_argument313); if (state.failed) return retval;
				if (state.backtracking == 0) {
				PATH62_tree = (CommonTree)adaptor.Create(PATH62);
				root_0 = (CommonTree)adaptor.BecomeRoot(PATH62_tree, root_0);
				}
				DebugLocation(41, 10);
				// ./find/Find.g:41:10: ( WS )?
				int alt30=2;
				try { DebugEnterSubRule(30);
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==WS))
				{
					alt30 = 1;
				}
				} finally { DebugExitDecision(30); }
				switch (alt30)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:41:10: WS
					{
					DebugLocation(41, 10);
					WS63=(IToken)Match(input,WS,Follow._WS_in_argument316); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS63_tree = (CommonTree)adaptor.Create(WS63);
					adaptor.AddChild(root_0, WS63_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(30); }

				DebugLocation(41, 14);
				EQ64=(IToken)Match(input,EQ,Follow._EQ_in_argument319); if (state.failed) return retval;
				if (state.backtracking == 0) {
				EQ64_tree = (CommonTree)adaptor.Create(EQ64);
				adaptor.AddChild(root_0, EQ64_tree);
				}
				DebugLocation(41, 17);
				// ./find/Find.g:41:17: ( WS )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==WS))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:41:17: WS
					{
					DebugLocation(41, 17);
					WS65=(IToken)Match(input,WS,Follow._WS_in_argument321); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WS65_tree = (CommonTree)adaptor.Create(WS65);
					adaptor.AddChild(root_0, WS65_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(41, 21);
				PushFollow(Follow._value_in_argument324);
				value66=value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, value66.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argument", 8);
			LeaveRule("argument", 8);
			LeaveRule_argument();
		}
		DebugLocation(42, 1);
		} finally { DebugExitRule(GrammarFileName, "argument"); }
		return retval;

	}
	// $ANTLR end "argument"

	partial void EnterRule_value();
	partial void LeaveRule_value();

	// $ANTLR start "value"
	// ./find/Find.g:44:1: value : ( STRING_LITERAL | UNQOTED_LITERAL );
	[GrammarRule("value")]
	private AstParserRuleReturnScope<CommonTree, IToken> value()
	{
		EnterRule_value();
		EnterRule("value", 9);
		TraceIn("value", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set67 = default(IToken);

		CommonTree set67_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "value");
		DebugLocation(44, 18);
		try
		{
			// ./find/Find.g:45:2: ( STRING_LITERAL | UNQOTED_LITERAL )
			DebugEnterAlt(1);
			// ./find/Find.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(45, 2);

			set67=(IToken)input.LT(1);
			if (input.LA(1)==STRING_LITERAL||input.LA(1)==UNQOTED_LITERAL)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set67));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value", 9);
			LeaveRule("value", 9);
			LeaveRule_value();
		}
		DebugLocation(46, 18);
		} finally { DebugExitRule(GrammarFileName, "value"); }
		return retval;

	}
	// $ANTLR end "value"

	partial void EnterRule_synpred3_Find_fragment();
	partial void LeaveRule_synpred3_Find_fragment();

	// $ANTLR start synpred3_Find
	public void synpred3_Find_fragment()
	{
		EnterRule_synpred3_Find_fragment();
		EnterRule("synpred3_Find_fragment", 12);
		TraceIn("synpred3_Find_fragment", 12);
		try
		{
			// ./find/Find.g:21:12: ( WS )
			DebugEnterAlt(1);
			// ./find/Find.g:21:12: WS
			{
			DebugLocation(21, 12);
			Match(input,WS,Follow._WS_in_synpred3_Find96); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_Find_fragment", 12);
			LeaveRule("synpred3_Find_fragment", 12);
			LeaveRule_synpred3_Find_fragment();
		}
	}
	// $ANTLR end synpred3_Find
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_commandline66 = new BitSet(new ulong[]{0x15BE22UL});
		public static readonly BitSet _paren_expr_in_expr77 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _or_expr_in_expr82 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_paren_expr93 = new BitSet(new ulong[]{0x57B620UL});
		public static readonly BitSet _WS_in_paren_expr96 = new BitSet(new ulong[]{0x57B620UL});
		public static readonly BitSet _or_expr_in_paren_expr99 = new BitSet(new ulong[]{0x57B620UL});
		public static readonly BitSet _WS_in_paren_expr102 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _RPAREN_in_paren_expr105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_expr_in_or_expr113 = new BitSet(new ulong[]{0x404002UL});
		public static readonly BitSet _WS_in_or_expr116 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _OR_in_or_expr119 = new BitSet(new ulong[]{0x55B620UL});
		public static readonly BitSet _WS_in_or_expr122 = new BitSet(new ulong[]{0x15B620UL});
		public static readonly BitSet _and_expr_in_or_expr125 = new BitSet(new ulong[]{0x404002UL});
		public static readonly BitSet _eql_expr_in_and_expr135 = new BitSet(new ulong[]{0x400012UL});
		public static readonly BitSet _WS_in_and_expr138 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _AND_in_and_expr141 = new BitSet(new ulong[]{0x55B620UL});
		public static readonly BitSet _WS_in_and_expr144 = new BitSet(new ulong[]{0x15B620UL});
		public static readonly BitSet _eql_expr_in_and_expr147 = new BitSet(new ulong[]{0x400012UL});
		public static readonly BitSet _not_expr_in_eql_expr157 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argument_in_eql_expr162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not_expr169 = new BitSet(new ulong[]{0x559620UL});
		public static readonly BitSet _WS_in_not_expr172 = new BitSet(new ulong[]{0x159620UL});
		public static readonly BitSet _argument_in_not_expr175 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_not_expr179 = new BitSet(new ulong[]{0x400800UL});
		public static readonly BitSet _WS_in_not_expr182 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _paren_expr_in_not_expr185 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAME_in_argument194 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument197 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument200 = new BitSet(new ulong[]{0x680000UL});
		public static readonly BitSet _WS_in_argument202 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _value_in_argument205 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INAME_in_argument210 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument213 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument216 = new BitSet(new ulong[]{0x680000UL});
		public static readonly BitSet _WS_in_argument218 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _value_in_argument221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGEX_in_argument227 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument230 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument233 = new BitSet(new ulong[]{0x680000UL});
		public static readonly BitSet _WS_in_argument235 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _value_in_argument238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IREGEX_in_argument244 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument247 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument250 = new BitSet(new ulong[]{0x680000UL});
		public static readonly BitSet _WS_in_argument252 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _value_in_argument255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_argument262 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument265 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument268 = new BitSet(new ulong[]{0x600000UL});
		public static readonly BitSet _WS_in_argument270 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _UNQOTED_LITERAL_in_argument273 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SIZE_in_argument279 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument282 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument285 = new BitSet(new ulong[]{0x600000UL});
		public static readonly BitSet _WS_in_argument287 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _UNQOTED_LITERAL_in_argument290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEPTH_in_argument296 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument299 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument302 = new BitSet(new ulong[]{0x600000UL});
		public static readonly BitSet _WS_in_argument304 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _UNQOTED_LITERAL_in_argument307 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PATH_in_argument313 = new BitSet(new ulong[]{0x400040UL});
		public static readonly BitSet _WS_in_argument316 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _EQ_in_argument319 = new BitSet(new ulong[]{0x680000UL});
		public static readonly BitSet _WS_in_argument321 = new BitSet(new ulong[]{0x280000UL});
		public static readonly BitSet _value_in_argument324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WS_in_synpred3_Find96 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  find 
