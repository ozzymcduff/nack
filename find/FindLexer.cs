//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 ./find/Find.g 2012-12-27 13:45:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  find 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class FindLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int DEPTH=5;
	public const int EQ=6;
	public const int ESC=7;
	public const int HEX_DIGIT=8;
	public const int INAME=9;
	public const int IREGEX=10;
	public const int LPAREN=11;
	public const int NAME=12;
	public const int NOT=13;
	public const int OR=14;
	public const int PATH=15;
	public const int REGEX=16;
	public const int RPAREN=17;
	public const int SIZE=18;
	public const int STRING_LITERAL=19;
	public const int TYPE=20;
	public const int UNQOTED_LITERAL=21;
	public const int WS=22;

    // delegates
    // delegators

	public FindLexer()
	{
		OnCreated();
	}

	public FindLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public FindLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "./find/Find.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_NAME();
	partial void LeaveRule_NAME();

	// $ANTLR start "NAME"
	[GrammarRule("NAME")]
	private void mNAME()
	{
		EnterRule_NAME();
		EnterRule("NAME", 1);
		TraceIn("NAME", 1);
		try
		{
			int _type = NAME;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:48:5: ( '-name' )
			DebugEnterAlt(1);
			// ./find/Find.g:48:6: '-name'
			{
			DebugLocation(48, 6);
			Match("-name"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NAME", 1);
			LeaveRule("NAME", 1);
			LeaveRule_NAME();
		}
	}
	// $ANTLR end "NAME"

	partial void EnterRule_INAME();
	partial void LeaveRule_INAME();

	// $ANTLR start "INAME"
	[GrammarRule("INAME")]
	private void mINAME()
	{
		EnterRule_INAME();
		EnterRule("INAME", 2);
		TraceIn("INAME", 2);
		try
		{
			int _type = INAME;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:49:6: ( '-iname' )
			DebugEnterAlt(1);
			// ./find/Find.g:49:7: '-iname'
			{
			DebugLocation(49, 7);
			Match("-iname"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INAME", 2);
			LeaveRule("INAME", 2);
			LeaveRule_INAME();
		}
	}
	// $ANTLR end "INAME"

	partial void EnterRule_REGEX();
	partial void LeaveRule_REGEX();

	// $ANTLR start "REGEX"
	[GrammarRule("REGEX")]
	private void mREGEX()
	{
		EnterRule_REGEX();
		EnterRule("REGEX", 3);
		TraceIn("REGEX", 3);
		try
		{
			int _type = REGEX;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:50:6: ( '-regex' )
			DebugEnterAlt(1);
			// ./find/Find.g:50:7: '-regex'
			{
			DebugLocation(50, 7);
			Match("-regex"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REGEX", 3);
			LeaveRule("REGEX", 3);
			LeaveRule_REGEX();
		}
	}
	// $ANTLR end "REGEX"

	partial void EnterRule_IREGEX();
	partial void LeaveRule_IREGEX();

	// $ANTLR start "IREGEX"
	[GrammarRule("IREGEX")]
	private void mIREGEX()
	{
		EnterRule_IREGEX();
		EnterRule("IREGEX", 4);
		TraceIn("IREGEX", 4);
		try
		{
			int _type = IREGEX;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:51:7: ( '-iregex' )
			DebugEnterAlt(1);
			// ./find/Find.g:51:8: '-iregex'
			{
			DebugLocation(51, 8);
			Match("-iregex"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IREGEX", 4);
			LeaveRule("IREGEX", 4);
			LeaveRule_IREGEX();
		}
	}
	// $ANTLR end "IREGEX"

	partial void EnterRule_PATH();
	partial void LeaveRule_PATH();

	// $ANTLR start "PATH"
	[GrammarRule("PATH")]
	private void mPATH()
	{
		EnterRule_PATH();
		EnterRule("PATH", 5);
		TraceIn("PATH", 5);
		try
		{
			int _type = PATH;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:52:5: ( '-path' )
			DebugEnterAlt(1);
			// ./find/Find.g:52:6: '-path'
			{
			DebugLocation(52, 6);
			Match("-path"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PATH", 5);
			LeaveRule("PATH", 5);
			LeaveRule_PATH();
		}
	}
	// $ANTLR end "PATH"

	partial void EnterRule_TYPE();
	partial void LeaveRule_TYPE();

	// $ANTLR start "TYPE"
	[GrammarRule("TYPE")]
	private void mTYPE()
	{
		EnterRule_TYPE();
		EnterRule("TYPE", 6);
		TraceIn("TYPE", 6);
		try
		{
			int _type = TYPE;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:53:5: ( '-type' )
			DebugEnterAlt(1);
			// ./find/Find.g:53:6: '-type'
			{
			DebugLocation(53, 6);
			Match("-type"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TYPE", 6);
			LeaveRule("TYPE", 6);
			LeaveRule_TYPE();
		}
	}
	// $ANTLR end "TYPE"

	partial void EnterRule_SIZE();
	partial void LeaveRule_SIZE();

	// $ANTLR start "SIZE"
	[GrammarRule("SIZE")]
	private void mSIZE()
	{
		EnterRule_SIZE();
		EnterRule("SIZE", 7);
		TraceIn("SIZE", 7);
		try
		{
			int _type = SIZE;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:54:5: ( '-size' )
			DebugEnterAlt(1);
			// ./find/Find.g:54:6: '-size'
			{
			DebugLocation(54, 6);
			Match("-size"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SIZE", 7);
			LeaveRule("SIZE", 7);
			LeaveRule_SIZE();
		}
	}
	// $ANTLR end "SIZE"

	partial void EnterRule_DEPTH();
	partial void LeaveRule_DEPTH();

	// $ANTLR start "DEPTH"
	[GrammarRule("DEPTH")]
	private void mDEPTH()
	{
		EnterRule_DEPTH();
		EnterRule("DEPTH", 8);
		TraceIn("DEPTH", 8);
		try
		{
			int _type = DEPTH;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:55:6: ( '-depth' )
			DebugEnterAlt(1);
			// ./find/Find.g:55:7: '-depth'
			{
			DebugLocation(55, 7);
			Match("-depth"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEPTH", 8);
			LeaveRule("DEPTH", 8);
			LeaveRule_DEPTH();
		}
	}
	// $ANTLR end "DEPTH"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 9);
		TraceIn("LPAREN", 9);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:56:7: ( '-(' )
			DebugEnterAlt(1);
			// ./find/Find.g:56:9: '-('
			{
			DebugLocation(56, 9);
			Match("-("); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 9);
			LeaveRule("LPAREN", 9);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 10);
		TraceIn("RPAREN", 10);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:57:7: ( '-)' )
			DebugEnterAlt(1);
			// ./find/Find.g:57:10: '-)'
			{
			DebugLocation(57, 10);
			Match("-)"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 10);
			LeaveRule("RPAREN", 10);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 11);
		TraceIn("AND", 11);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:58:4: ( '-AND' | '-and' | '-&&' )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0=='-'))
			{
				switch (input.LA(2))
				{
				case 'A':
					{
					alt1 = 1;
					}
					break;
				case 'a':
					{
					alt1 = 2;
					}
					break;
				case '&':
					{
					alt1 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 1, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:58:7: '-AND'
				{
				DebugLocation(58, 7);
				Match("-AND"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:58:15: '-and'
				{
				DebugLocation(58, 15);
				Match("-and"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:58:24: '-&&'
				{
				DebugLocation(58, 24);
				Match("-&&"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 11);
			LeaveRule("AND", 11);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 12);
		TraceIn("OR", 12);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:59:3: ( '-OR' | '-or' | '-||' )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0=='-'))
			{
				switch (input.LA(2))
				{
				case 'O':
					{
					alt2 = 1;
					}
					break;
				case 'o':
					{
					alt2 = 2;
					}
					break;
				case '|':
					{
					alt2 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:59:6: '-OR'
				{
				DebugLocation(59, 6);
				Match("-OR"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:59:14: '-or'
				{
				DebugLocation(59, 14);
				Match("-or"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:59:21: '-||'
				{
				DebugLocation(59, 21);
				Match("-||"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 12);
			LeaveRule("OR", 12);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 13);
		TraceIn("NOT", 13);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:60:5: ( '-!' | '-NOT' | '-not' )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0=='-'))
			{
				switch (input.LA(2))
				{
				case '!':
					{
					alt3 = 1;
					}
					break;
				case 'N':
					{
					alt3 = 2;
					}
					break;
				case 'n':
					{
					alt3 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:60:8: '-!'
				{
				DebugLocation(60, 8);
				Match("-!"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:60:15: '-NOT'
				{
				DebugLocation(60, 15);
				Match("-NOT"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:60:24: '-not'
				{
				DebugLocation(60, 24);
				Match("-not"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 13);
			LeaveRule("NOT", 13);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_STRING_LITERAL();
	partial void LeaveRule_STRING_LITERAL();

	// $ANTLR start "STRING_LITERAL"
	[GrammarRule("STRING_LITERAL")]
	private void mSTRING_LITERAL()
	{
		EnterRule_STRING_LITERAL();
		EnterRule("STRING_LITERAL", 14);
		TraceIn("STRING_LITERAL", 14);
		try
		{
			int _type = STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:62:2: ( '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"' )
			DebugEnterAlt(1);
			// ./find/Find.g:62:4: '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"'
			{
			DebugLocation(62, 4);
			Match('\"'); 
			DebugLocation(62, 8);
			// ./find/Find.g:62:8: ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0=='\\'))
				{
					alt4 = 1;
				}
				else if (((LA4_0>='\u0000' && LA4_0<='\t')||(LA4_0>='\u000B' && LA4_0<='\f')||(LA4_0>='\u000E' && LA4_0<='!')||(LA4_0>='#' && LA4_0<='[')||(LA4_0>=']' && LA4_0<='\uFFFF')))
				{
					alt4 = 2;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:62:9: ESC
					{
					DebugLocation(62, 9);
					mESC(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ./find/Find.g:62:13: ~ ( '\"' | '\\\\' | '\\n' | '\\r' )
					{
					DebugLocation(62, 13);
					input.Consume();


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(62, 37);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL", 14);
			LeaveRule("STRING_LITERAL", 14);
			LeaveRule_STRING_LITERAL();
		}
	}
	// $ANTLR end "STRING_LITERAL"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 15);
		TraceIn("ESC", 15);
		try
		{
			// ./find/Find.g:75:2: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? ) )
			DebugEnterAlt(1);
			// ./find/Find.g:75:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? )
			{
			DebugLocation(75, 4);
			Match('\\'); 
			DebugLocation(76, 3);
			// ./find/Find.g:76:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? )
			int alt9=11;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case 'n':
				{
				alt9 = 1;
				}
				break;
			case 'r':
				{
				alt9 = 2;
				}
				break;
			case 't':
				{
				alt9 = 3;
				}
				break;
			case 'b':
				{
				alt9 = 4;
				}
				break;
			case 'f':
				{
				alt9 = 5;
				}
				break;
			case '\"':
				{
				alt9 = 6;
				}
				break;
			case '\'':
				{
				alt9 = 7;
				}
				break;
			case '\\':
				{
				alt9 = 8;
				}
				break;
			case 'u':
				{
				alt9 = 9;
				}
				break;
			case '0':
			case '1':
			case '2':
			case '3':
				{
				alt9 = 10;
				}
				break;
			case '4':
			case '5':
			case '6':
			case '7':
				{
				alt9 = 11;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:76:5: 'n'
				{
				DebugLocation(76, 5);
				Match('n'); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:77:5: 'r'
				{
				DebugLocation(77, 5);
				Match('r'); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:78:5: 't'
				{
				DebugLocation(78, 5);
				Match('t'); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ./find/Find.g:79:5: 'b'
				{
				DebugLocation(79, 5);
				Match('b'); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ./find/Find.g:80:5: 'f'
				{
				DebugLocation(80, 5);
				Match('f'); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ./find/Find.g:81:5: '\"'
				{
				DebugLocation(81, 5);
				Match('\"'); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ./find/Find.g:82:5: '\\''
				{
				DebugLocation(82, 5);
				Match('\''); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ./find/Find.g:83:5: '\\\\'
				{
				DebugLocation(83, 5);
				Match('\\'); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// ./find/Find.g:84:5: ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
				{
				DebugLocation(84, 5);
				// ./find/Find.g:84:5: ( 'u' )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0=='u'))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:84:6: 'u'
						{
						DebugLocation(84, 6);
						Match('u'); 

						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(84, 12);
				mHEX_DIGIT(); 
				DebugLocation(84, 22);
				mHEX_DIGIT(); 
				DebugLocation(84, 32);
				mHEX_DIGIT(); 
				DebugLocation(84, 42);
				mHEX_DIGIT(); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// ./find/Find.g:85:5: '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )?
				{
				DebugLocation(85, 5);
				MatchRange('0','3'); 
				DebugLocation(86, 4);
				// ./find/Find.g:86:4: ( '0' .. '7' ( '0' .. '7' )? )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if (((LA7_0>='0' && LA7_0<='7')))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:90:6: '0' .. '7' ( '0' .. '7' )?
					{
					DebugLocation(90, 6);
					MatchRange('0','7'); 
					DebugLocation(91, 5);
					// ./find/Find.g:91:5: ( '0' .. '7' )?
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if (((LA6_0>='0' && LA6_0<='7')))
					{
						alt6 = 1;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:
						{
						DebugLocation(91, 5);
						input.Consume();


						}
						break;

					}
					} finally { DebugExitSubRule(6); }


					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// ./find/Find.g:98:5: '4' .. '7' ( '0' .. '7' )?
				{
				DebugLocation(98, 5);
				MatchRange('4','7'); 
				DebugLocation(99, 4);
				// ./find/Find.g:99:4: ( '0' .. '7' )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>='0' && LA8_0<='7')))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(99, 4);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

		}
		finally
		{
			TraceOut("ESC", 15);
			LeaveRule("ESC", 15);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_HEX_DIGIT();
	partial void LeaveRule_HEX_DIGIT();

	// $ANTLR start "HEX_DIGIT"
	[GrammarRule("HEX_DIGIT")]
	private void mHEX_DIGIT()
	{
		EnterRule_HEX_DIGIT();
		EnterRule("HEX_DIGIT", 16);
		TraceIn("HEX_DIGIT", 16);
		try
		{
			// ./find/Find.g:112:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
			DebugEnterAlt(1);
			// ./find/Find.g:
			{
			DebugLocation(112, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEX_DIGIT", 16);
			LeaveRule("HEX_DIGIT", 16);
			LeaveRule_HEX_DIGIT();
		}
	}
	// $ANTLR end "HEX_DIGIT"

	partial void EnterRule_UNQOTED_LITERAL();
	partial void LeaveRule_UNQOTED_LITERAL();

	// $ANTLR start "UNQOTED_LITERAL"
	[GrammarRule("UNQOTED_LITERAL")]
	private void mUNQOTED_LITERAL()
	{
		EnterRule_UNQOTED_LITERAL();
		EnterRule("UNQOTED_LITERAL", 17);
		TraceIn("UNQOTED_LITERAL", 17);
		try
		{
			int _type = UNQOTED_LITERAL;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:114:2: ( (~ ( ' ' | '-' | '=' ) )* )
			DebugEnterAlt(1);
			// ./find/Find.g:114:4: (~ ( ' ' | '-' | '=' ) )*
			{
			DebugLocation(114, 4);
			// ./find/Find.g:114:4: (~ ( ' ' | '-' | '=' ) )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if (((LA10_0>='\u0000' && LA10_0<='\u001F')||(LA10_0>='!' && LA10_0<=',')||(LA10_0>='.' && LA10_0<='<')||(LA10_0>='>' && LA10_0<='\uFFFF')))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(114, 4);
					input.Consume();


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNQOTED_LITERAL", 17);
			LeaveRule("UNQOTED_LITERAL", 17);
			LeaveRule_UNQOTED_LITERAL();
		}
	}
	// $ANTLR end "UNQOTED_LITERAL"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 18);
		TraceIn("EQ", 18);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:115:4: ( '=' )
			DebugEnterAlt(1);
			// ./find/Find.g:115:6: '='
			{
			DebugLocation(115, 6);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 18);
			LeaveRule("EQ", 18);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 19);
		TraceIn("WS", 19);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:116:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// ./find/Find.g:116:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
			{
			DebugLocation(116, 6);
			// ./find/Find.g:116:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if (((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' '))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(116, 6);
					input.Consume();


					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(116, 34);
			_channel = Hidden ;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 19);
			LeaveRule("WS", 19);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// ./find/Find.g:1:8: ( NAME | INAME | REGEX | IREGEX | PATH | TYPE | SIZE | DEPTH | LPAREN | RPAREN | AND | OR | NOT | STRING_LITERAL | UNQOTED_LITERAL | EQ | WS )
		int alt12=17;
		try { DebugEnterDecision(12, false);
		try
		{
			alt12 = dfa12.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(12); }
		switch (alt12)
		{
		case 1:
			DebugEnterAlt(1);
			// ./find/Find.g:1:10: NAME
			{
			DebugLocation(1, 10);
			mNAME(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// ./find/Find.g:1:15: INAME
			{
			DebugLocation(1, 15);
			mINAME(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// ./find/Find.g:1:21: REGEX
			{
			DebugLocation(1, 21);
			mREGEX(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// ./find/Find.g:1:27: IREGEX
			{
			DebugLocation(1, 27);
			mIREGEX(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// ./find/Find.g:1:34: PATH
			{
			DebugLocation(1, 34);
			mPATH(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// ./find/Find.g:1:39: TYPE
			{
			DebugLocation(1, 39);
			mTYPE(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// ./find/Find.g:1:44: SIZE
			{
			DebugLocation(1, 44);
			mSIZE(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// ./find/Find.g:1:49: DEPTH
			{
			DebugLocation(1, 49);
			mDEPTH(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// ./find/Find.g:1:55: LPAREN
			{
			DebugLocation(1, 55);
			mLPAREN(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// ./find/Find.g:1:62: RPAREN
			{
			DebugLocation(1, 62);
			mRPAREN(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// ./find/Find.g:1:69: AND
			{
			DebugLocation(1, 69);
			mAND(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// ./find/Find.g:1:73: OR
			{
			DebugLocation(1, 73);
			mOR(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// ./find/Find.g:1:76: NOT
			{
			DebugLocation(1, 76);
			mNOT(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// ./find/Find.g:1:80: STRING_LITERAL
			{
			DebugLocation(1, 80);
			mSTRING_LITERAL(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// ./find/Find.g:1:95: UNQOTED_LITERAL
			{
			DebugLocation(1, 95);
			mUNQOTED_LITERAL(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// ./find/Find.g:1:111: EQ
			{
			DebugLocation(1, 111);
			mEQ(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// ./find/Find.g:1:114: WS
			{
			DebugLocation(1, 114);
			mWS(); 

			}
			break;

		}

	}


	#region DFA
	DFA12 dfa12;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa12 = new DFA12(this, SpecialStateTransition12);
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x1\x4\x1\xFFFF\x2\x4\xF\xFFFF\x2\x4\x1\x16\x4\xFFFF\x12\x4";
		private const string DFA12_eofS =
			"\x2C\xFFFF";
		private const string DFA12_minS =
			"\x1\x9\x1\x21\x1\x0\x1\x9\x3\xFFFF\x1\x61\x1\x6E\xA\xFFFF\x1\x22\x2\x0"+
			"\x4\xFFFF\x8\x0\x1\x30\x2\x0\x1\x30\x2\x0\x1\x30\x1\x0\x1\x30\x1\x0";
		private const string DFA12_maxS =
			"\x1\x3D\x1\x7C\x1\xFFFF\x1\x20\x3\xFFFF\x1\x6F\x1\x72\xA\xFFFF\x1\x75"+
			"\x2\xFFFF\x4\xFFFF\x8\xFFFF\x1\x75\x2\xFFFF\x1\x66\x2\xFFFF\x1\x66\x1"+
			"\xFFFF\x1\x66\x1\xFFFF";
		private const string DFA12_acceptS =
			"\x4\xFFFF\x1\xF\x1\x10\x1\x11\x2\xFFFF\x1\x3\x1\x5\x1\x6\x1\x7\x1\x8"+
			"\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x3\xFFFF\x1\xE\x1\x1\x1\x2\x1\x4\x12\xFFFF";
		private const string DFA12_specialS =
			"\x2\xFFFF\x1\x10\x11\xFFFF\x1\x6\x1\x0\x4\xFFFF\x1\x2\x1\x8\x1\x9\x1"+
			"\x4\x1\x5\x1\xD\x1\xE\x1\xB\x1\xFFFF\x1\xF\x1\x3\x1\xFFFF\x1\xC\x1\x1"+
			"\x1\xFFFF\x1\x7\x1\xFFFF\x1\xA}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x2\x3\x2\xFFFF\x1\x3\x12\xFFFF\x1\x6\x1\xFFFF\x1\x2\xA\xFFFF\x1\x1"+
				"\xF\xFFFF\x1\x5",
				"\x1\x12\x4\xFFFF\x1\x10\x1\xFFFF\x1\xE\x1\xF\x17\xFFFF\x1\x10\xC\xFFFF"+
				"\x1\x12\x1\x11\x11\xFFFF\x1\x10\x2\xFFFF\x1\xD\x4\xFFFF\x1\x8\x4\xFFFF"+
				"\x1\x7\x1\x11\x1\xA\x1\xFFFF\x1\x9\x1\xC\x1\xB\x7\xFFFF\x1\x11",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\x2\x3\x2\xFFFF\x1\x3\x12\xFFFF\x1\x6",
				"",
				"",
				"",
				"\x1\x17\xD\xFFFF\x1\x12",
				"\x1\x18\x3\xFFFF\x1\x19",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x1F\x4\xFFFF\x1\x20\x8\xFFFF\x4\x23\x4\x24\x24\xFFFF\x1\x21\x5"+
				"\xFFFF\x1\x1D\x3\xFFFF\x1\x1E\x7\xFFFF\x1\x1A\x3\xFFFF\x1\x1B\x1\xFFFF"+
				"\x1\x1C\x1\x22",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\x20\x4\x1\xFFFF\xC\x4\x1\xFFFF\xF\x4\x1\xFFFF\xFFC2\x4",
				"",
				"",
				"",
				"",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x25\x7\xFFFF\x6\x25\x1A\xFFFF\x6\x25\xE\xFFFF\x1\x22",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\x2\x14\x8\x26\x5\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\x2\x14\x8\x27\x5\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x28\x7\xFFFF\x6\x28\x1A\xFFFF\x6\x28",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\x2\x14\x8\x29\x5\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x2A\x7\xFFFF\x6\x2A\x1A\xFFFF\x6\x2A",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14",
				"\xA\x2B\x7\xFFFF\x6\x2B\x1A\xFFFF\x6\x2B",
				"\xA\x14\x1\xFFFF\x2\x14\x1\xFFFF\x12\x14\x1\x16\x1\x14\x1\x15\xA\x14"+
				"\x1\x16\xF\x14\x1\x16\x1E\x14\x1\x13\xFFA3\x14"
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( NAME | INAME | REGEX | IREGEX | PATH | TYPE | SIZE | DEPTH | LPAREN | RPAREN | AND | OR | NOT | STRING_LITERAL | UNQOTED_LITERAL | EQ | WS );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition12(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA12_21 = input.LA(1);

				s = -1;
				if (((LA12_21>='\u0000' && LA12_21<='\u001F')||(LA12_21>='!' && LA12_21<=',')||(LA12_21>='.' && LA12_21<='<')||(LA12_21>='>' && LA12_21<='\uFFFF'))) {s = 4;}

				else s = 22;

				if (s >= 0) return s;
				break;

			case 1:
				int LA12_39 = input.LA(1);

				s = -1;
				if ((LA12_39=='\"')) {s = 21;}

				else if ((LA12_39=='\\')) {s = 19;}

				else if (((LA12_39>='\u0000' && LA12_39<='\t')||(LA12_39>='\u000B' && LA12_39<='\f')||(LA12_39>='\u000E' && LA12_39<='\u001F')||LA12_39=='!'||(LA12_39>='#' && LA12_39<=',')||(LA12_39>='.' && LA12_39<='<')||(LA12_39>='>' && LA12_39<='[')||(LA12_39>=']' && LA12_39<='\uFFFF'))) {s = 20;}

				else if ((LA12_39==' '||LA12_39=='-'||LA12_39=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 2:
				int LA12_26 = input.LA(1);

				s = -1;
				if ((LA12_26=='\"')) {s = 21;}

				else if ((LA12_26=='\\')) {s = 19;}

				else if (((LA12_26>='\u0000' && LA12_26<='\t')||(LA12_26>='\u000B' && LA12_26<='\f')||(LA12_26>='\u000E' && LA12_26<='\u001F')||LA12_26=='!'||(LA12_26>='#' && LA12_26<=',')||(LA12_26>='.' && LA12_26<='<')||(LA12_26>='>' && LA12_26<='[')||(LA12_26>=']' && LA12_26<='\uFFFF'))) {s = 20;}

				else if ((LA12_26==' '||LA12_26=='-'||LA12_26=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 3:
				int LA12_36 = input.LA(1);

				s = -1;
				if (((LA12_36>='0' && LA12_36<='7'))) {s = 39;}

				else if ((LA12_36=='\"')) {s = 21;}

				else if ((LA12_36=='\\')) {s = 19;}

				else if (((LA12_36>='\u0000' && LA12_36<='\t')||(LA12_36>='\u000B' && LA12_36<='\f')||(LA12_36>='\u000E' && LA12_36<='\u001F')||LA12_36=='!'||(LA12_36>='#' && LA12_36<=',')||(LA12_36>='.' && LA12_36<='/')||(LA12_36>='8' && LA12_36<='<')||(LA12_36>='>' && LA12_36<='[')||(LA12_36>=']' && LA12_36<='\uFFFF'))) {s = 20;}

				else if ((LA12_36==' '||LA12_36=='-'||LA12_36=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 4:
				int LA12_29 = input.LA(1);

				s = -1;
				if ((LA12_29=='\"')) {s = 21;}

				else if ((LA12_29=='\\')) {s = 19;}

				else if (((LA12_29>='\u0000' && LA12_29<='\t')||(LA12_29>='\u000B' && LA12_29<='\f')||(LA12_29>='\u000E' && LA12_29<='\u001F')||LA12_29=='!'||(LA12_29>='#' && LA12_29<=',')||(LA12_29>='.' && LA12_29<='<')||(LA12_29>='>' && LA12_29<='[')||(LA12_29>=']' && LA12_29<='\uFFFF'))) {s = 20;}

				else if ((LA12_29==' '||LA12_29=='-'||LA12_29=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 5:
				int LA12_30 = input.LA(1);

				s = -1;
				if ((LA12_30=='\"')) {s = 21;}

				else if ((LA12_30=='\\')) {s = 19;}

				else if (((LA12_30>='\u0000' && LA12_30<='\t')||(LA12_30>='\u000B' && LA12_30<='\f')||(LA12_30>='\u000E' && LA12_30<='\u001F')||LA12_30=='!'||(LA12_30>='#' && LA12_30<=',')||(LA12_30>='.' && LA12_30<='<')||(LA12_30>='>' && LA12_30<='[')||(LA12_30>=']' && LA12_30<='\uFFFF'))) {s = 20;}

				else if ((LA12_30==' '||LA12_30=='-'||LA12_30=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 6:
				int LA12_20 = input.LA(1);

				s = -1;
				if ((LA12_20=='\"')) {s = 21;}

				else if ((LA12_20=='\\')) {s = 19;}

				else if (((LA12_20>='\u0000' && LA12_20<='\t')||(LA12_20>='\u000B' && LA12_20<='\f')||(LA12_20>='\u000E' && LA12_20<='\u001F')||LA12_20=='!'||(LA12_20>='#' && LA12_20<=',')||(LA12_20>='.' && LA12_20<='<')||(LA12_20>='>' && LA12_20<='[')||(LA12_20>=']' && LA12_20<='\uFFFF'))) {s = 20;}

				else if ((LA12_20==' '||LA12_20=='-'||LA12_20=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 7:
				int LA12_41 = input.LA(1);

				s = -1;
				if ((LA12_41=='\"')) {s = 21;}

				else if ((LA12_41=='\\')) {s = 19;}

				else if (((LA12_41>='\u0000' && LA12_41<='\t')||(LA12_41>='\u000B' && LA12_41<='\f')||(LA12_41>='\u000E' && LA12_41<='\u001F')||LA12_41=='!'||(LA12_41>='#' && LA12_41<=',')||(LA12_41>='.' && LA12_41<='<')||(LA12_41>='>' && LA12_41<='[')||(LA12_41>=']' && LA12_41<='\uFFFF'))) {s = 20;}

				else if ((LA12_41==' '||LA12_41=='-'||LA12_41=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 8:
				int LA12_27 = input.LA(1);

				s = -1;
				if ((LA12_27=='\"')) {s = 21;}

				else if ((LA12_27=='\\')) {s = 19;}

				else if (((LA12_27>='\u0000' && LA12_27<='\t')||(LA12_27>='\u000B' && LA12_27<='\f')||(LA12_27>='\u000E' && LA12_27<='\u001F')||LA12_27=='!'||(LA12_27>='#' && LA12_27<=',')||(LA12_27>='.' && LA12_27<='<')||(LA12_27>='>' && LA12_27<='[')||(LA12_27>=']' && LA12_27<='\uFFFF'))) {s = 20;}

				else if ((LA12_27==' '||LA12_27=='-'||LA12_27=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 9:
				int LA12_28 = input.LA(1);

				s = -1;
				if ((LA12_28=='\"')) {s = 21;}

				else if ((LA12_28=='\\')) {s = 19;}

				else if (((LA12_28>='\u0000' && LA12_28<='\t')||(LA12_28>='\u000B' && LA12_28<='\f')||(LA12_28>='\u000E' && LA12_28<='\u001F')||LA12_28=='!'||(LA12_28>='#' && LA12_28<=',')||(LA12_28>='.' && LA12_28<='<')||(LA12_28>='>' && LA12_28<='[')||(LA12_28>=']' && LA12_28<='\uFFFF'))) {s = 20;}

				else if ((LA12_28==' '||LA12_28=='-'||LA12_28=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 10:
				int LA12_43 = input.LA(1);

				s = -1;
				if ((LA12_43=='\"')) {s = 21;}

				else if ((LA12_43=='\\')) {s = 19;}

				else if (((LA12_43>='\u0000' && LA12_43<='\t')||(LA12_43>='\u000B' && LA12_43<='\f')||(LA12_43>='\u000E' && LA12_43<='\u001F')||LA12_43=='!'||(LA12_43>='#' && LA12_43<=',')||(LA12_43>='.' && LA12_43<='<')||(LA12_43>='>' && LA12_43<='[')||(LA12_43>=']' && LA12_43<='\uFFFF'))) {s = 20;}

				else if ((LA12_43==' '||LA12_43=='-'||LA12_43=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 11:
				int LA12_33 = input.LA(1);

				s = -1;
				if ((LA12_33=='\"')) {s = 21;}

				else if ((LA12_33=='\\')) {s = 19;}

				else if (((LA12_33>='\u0000' && LA12_33<='\t')||(LA12_33>='\u000B' && LA12_33<='\f')||(LA12_33>='\u000E' && LA12_33<='\u001F')||LA12_33=='!'||(LA12_33>='#' && LA12_33<=',')||(LA12_33>='.' && LA12_33<='<')||(LA12_33>='>' && LA12_33<='[')||(LA12_33>=']' && LA12_33<='\uFFFF'))) {s = 20;}

				else if ((LA12_33==' '||LA12_33=='-'||LA12_33=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 12:
				int LA12_38 = input.LA(1);

				s = -1;
				if (((LA12_38>='0' && LA12_38<='7'))) {s = 41;}

				else if ((LA12_38=='\"')) {s = 21;}

				else if ((LA12_38=='\\')) {s = 19;}

				else if (((LA12_38>='\u0000' && LA12_38<='\t')||(LA12_38>='\u000B' && LA12_38<='\f')||(LA12_38>='\u000E' && LA12_38<='\u001F')||LA12_38=='!'||(LA12_38>='#' && LA12_38<=',')||(LA12_38>='.' && LA12_38<='/')||(LA12_38>='8' && LA12_38<='<')||(LA12_38>='>' && LA12_38<='[')||(LA12_38>=']' && LA12_38<='\uFFFF'))) {s = 20;}

				else if ((LA12_38==' '||LA12_38=='-'||LA12_38=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 13:
				int LA12_31 = input.LA(1);

				s = -1;
				if ((LA12_31=='\"')) {s = 21;}

				else if ((LA12_31=='\\')) {s = 19;}

				else if (((LA12_31>='\u0000' && LA12_31<='\t')||(LA12_31>='\u000B' && LA12_31<='\f')||(LA12_31>='\u000E' && LA12_31<='\u001F')||LA12_31=='!'||(LA12_31>='#' && LA12_31<=',')||(LA12_31>='.' && LA12_31<='<')||(LA12_31>='>' && LA12_31<='[')||(LA12_31>=']' && LA12_31<='\uFFFF'))) {s = 20;}

				else if ((LA12_31==' '||LA12_31=='-'||LA12_31=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 14:
				int LA12_32 = input.LA(1);

				s = -1;
				if ((LA12_32=='\"')) {s = 21;}

				else if ((LA12_32=='\\')) {s = 19;}

				else if (((LA12_32>='\u0000' && LA12_32<='\t')||(LA12_32>='\u000B' && LA12_32<='\f')||(LA12_32>='\u000E' && LA12_32<='\u001F')||LA12_32=='!'||(LA12_32>='#' && LA12_32<=',')||(LA12_32>='.' && LA12_32<='<')||(LA12_32>='>' && LA12_32<='[')||(LA12_32>=']' && LA12_32<='\uFFFF'))) {s = 20;}

				else if ((LA12_32==' '||LA12_32=='-'||LA12_32=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 15:
				int LA12_35 = input.LA(1);

				s = -1;
				if (((LA12_35>='0' && LA12_35<='7'))) {s = 38;}

				else if ((LA12_35=='\"')) {s = 21;}

				else if ((LA12_35=='\\')) {s = 19;}

				else if (((LA12_35>='\u0000' && LA12_35<='\t')||(LA12_35>='\u000B' && LA12_35<='\f')||(LA12_35>='\u000E' && LA12_35<='\u001F')||LA12_35=='!'||(LA12_35>='#' && LA12_35<=',')||(LA12_35>='.' && LA12_35<='/')||(LA12_35>='8' && LA12_35<='<')||(LA12_35>='>' && LA12_35<='[')||(LA12_35>=']' && LA12_35<='\uFFFF'))) {s = 20;}

				else if ((LA12_35==' '||LA12_35=='-'||LA12_35=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;

			case 16:
				int LA12_2 = input.LA(1);

				s = -1;
				if ((LA12_2=='\\')) {s = 19;}

				else if (((LA12_2>='\u0000' && LA12_2<='\t')||(LA12_2>='\u000B' && LA12_2<='\f')||(LA12_2>='\u000E' && LA12_2<='\u001F')||LA12_2=='!'||(LA12_2>='#' && LA12_2<=',')||(LA12_2>='.' && LA12_2<='<')||(LA12_2>='>' && LA12_2<='[')||(LA12_2>=']' && LA12_2<='\uFFFF'))) {s = 20;}

				else if ((LA12_2=='\"')) {s = 21;}

				else if ((LA12_2==' '||LA12_2=='-'||LA12_2=='=')) {s = 22;}

				else s = 4;

				if (s >= 0) return s;
				break;
		}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 12, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
 
	#endregion

}

} // namespace  find 
