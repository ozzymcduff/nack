//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 ./find/Find.g 2012-12-27 11:41:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  find 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class FindLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int T__23=23;
	public const int T__24=24;
	public const int AND=4;
	public const int DEPTH=5;
	public const int EQ=6;
	public const int ESC=7;
	public const int HEX_DIGIT=8;
	public const int INAME=9;
	public const int IREGEX=10;
	public const int LPAREN=11;
	public const int NAME=12;
	public const int NOT=13;
	public const int OR=14;
	public const int PATH=15;
	public const int REGEX=16;
	public const int RPAREN=17;
	public const int SIZE=18;
	public const int STRING_LITERAL=19;
	public const int TYPE=20;
	public const int UNQOTED_LITERAL=21;
	public const int WS=22;

    // delegates
    // delegators

	public FindLexer()
	{
		OnCreated();
	}

	public FindLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public FindLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "./find/Find.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__23();
	partial void LeaveRule_T__23();

	// $ANTLR start "T__23"
	[GrammarRule("T__23")]
	private void mT__23()
	{
		EnterRule_T__23();
		EnterRule("T__23", 1);
		TraceIn("T__23", 1);
		try
		{
			int _type = T__23;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:9:7: ( 'd' )
			DebugEnterAlt(1);
			// ./find/Find.g:9:9: 'd'
			{
			DebugLocation(9, 9);
			Match('d'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__23", 1);
			LeaveRule("T__23", 1);
			LeaveRule_T__23();
		}
	}
	// $ANTLR end "T__23"

	partial void EnterRule_T__24();
	partial void LeaveRule_T__24();

	// $ANTLR start "T__24"
	[GrammarRule("T__24")]
	private void mT__24()
	{
		EnterRule_T__24();
		EnterRule("T__24", 2);
		TraceIn("T__24", 2);
		try
		{
			int _type = T__24;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:10:7: ( 'f' )
			DebugEnterAlt(1);
			// ./find/Find.g:10:9: 'f'
			{
			DebugLocation(10, 9);
			Match('f'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__24", 2);
			LeaveRule("T__24", 2);
			LeaveRule_T__24();
		}
	}
	// $ANTLR end "T__24"

	partial void EnterRule_NAME();
	partial void LeaveRule_NAME();

	// $ANTLR start "NAME"
	[GrammarRule("NAME")]
	private void mNAME()
	{
		EnterRule_NAME();
		EnterRule("NAME", 3);
		TraceIn("NAME", 3);
		try
		{
			int _type = NAME;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:48:5: ( '-name' )
			DebugEnterAlt(1);
			// ./find/Find.g:48:6: '-name'
			{
			DebugLocation(48, 6);
			Match("-name"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NAME", 3);
			LeaveRule("NAME", 3);
			LeaveRule_NAME();
		}
	}
	// $ANTLR end "NAME"

	partial void EnterRule_INAME();
	partial void LeaveRule_INAME();

	// $ANTLR start "INAME"
	[GrammarRule("INAME")]
	private void mINAME()
	{
		EnterRule_INAME();
		EnterRule("INAME", 4);
		TraceIn("INAME", 4);
		try
		{
			int _type = INAME;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:49:6: ( '-iname' )
			DebugEnterAlt(1);
			// ./find/Find.g:49:7: '-iname'
			{
			DebugLocation(49, 7);
			Match("-iname"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INAME", 4);
			LeaveRule("INAME", 4);
			LeaveRule_INAME();
		}
	}
	// $ANTLR end "INAME"

	partial void EnterRule_REGEX();
	partial void LeaveRule_REGEX();

	// $ANTLR start "REGEX"
	[GrammarRule("REGEX")]
	private void mREGEX()
	{
		EnterRule_REGEX();
		EnterRule("REGEX", 5);
		TraceIn("REGEX", 5);
		try
		{
			int _type = REGEX;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:50:6: ( '-regex' )
			DebugEnterAlt(1);
			// ./find/Find.g:50:7: '-regex'
			{
			DebugLocation(50, 7);
			Match("-regex"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REGEX", 5);
			LeaveRule("REGEX", 5);
			LeaveRule_REGEX();
		}
	}
	// $ANTLR end "REGEX"

	partial void EnterRule_IREGEX();
	partial void LeaveRule_IREGEX();

	// $ANTLR start "IREGEX"
	[GrammarRule("IREGEX")]
	private void mIREGEX()
	{
		EnterRule_IREGEX();
		EnterRule("IREGEX", 6);
		TraceIn("IREGEX", 6);
		try
		{
			int _type = IREGEX;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:51:7: ( '-iregex' )
			DebugEnterAlt(1);
			// ./find/Find.g:51:8: '-iregex'
			{
			DebugLocation(51, 8);
			Match("-iregex"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IREGEX", 6);
			LeaveRule("IREGEX", 6);
			LeaveRule_IREGEX();
		}
	}
	// $ANTLR end "IREGEX"

	partial void EnterRule_PATH();
	partial void LeaveRule_PATH();

	// $ANTLR start "PATH"
	[GrammarRule("PATH")]
	private void mPATH()
	{
		EnterRule_PATH();
		EnterRule("PATH", 7);
		TraceIn("PATH", 7);
		try
		{
			int _type = PATH;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:52:5: ( '-path' )
			DebugEnterAlt(1);
			// ./find/Find.g:52:6: '-path'
			{
			DebugLocation(52, 6);
			Match("-path"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PATH", 7);
			LeaveRule("PATH", 7);
			LeaveRule_PATH();
		}
	}
	// $ANTLR end "PATH"

	partial void EnterRule_TYPE();
	partial void LeaveRule_TYPE();

	// $ANTLR start "TYPE"
	[GrammarRule("TYPE")]
	private void mTYPE()
	{
		EnterRule_TYPE();
		EnterRule("TYPE", 8);
		TraceIn("TYPE", 8);
		try
		{
			int _type = TYPE;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:53:5: ( '-type' )
			DebugEnterAlt(1);
			// ./find/Find.g:53:6: '-type'
			{
			DebugLocation(53, 6);
			Match("-type"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TYPE", 8);
			LeaveRule("TYPE", 8);
			LeaveRule_TYPE();
		}
	}
	// $ANTLR end "TYPE"

	partial void EnterRule_SIZE();
	partial void LeaveRule_SIZE();

	// $ANTLR start "SIZE"
	[GrammarRule("SIZE")]
	private void mSIZE()
	{
		EnterRule_SIZE();
		EnterRule("SIZE", 9);
		TraceIn("SIZE", 9);
		try
		{
			int _type = SIZE;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:54:5: ( '-size' )
			DebugEnterAlt(1);
			// ./find/Find.g:54:6: '-size'
			{
			DebugLocation(54, 6);
			Match("-size"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SIZE", 9);
			LeaveRule("SIZE", 9);
			LeaveRule_SIZE();
		}
	}
	// $ANTLR end "SIZE"

	partial void EnterRule_DEPTH();
	partial void LeaveRule_DEPTH();

	// $ANTLR start "DEPTH"
	[GrammarRule("DEPTH")]
	private void mDEPTH()
	{
		EnterRule_DEPTH();
		EnterRule("DEPTH", 10);
		TraceIn("DEPTH", 10);
		try
		{
			int _type = DEPTH;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:55:6: ( '-depth' )
			DebugEnterAlt(1);
			// ./find/Find.g:55:7: '-depth'
			{
			DebugLocation(55, 7);
			Match("-depth"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEPTH", 10);
			LeaveRule("DEPTH", 10);
			LeaveRule_DEPTH();
		}
	}
	// $ANTLR end "DEPTH"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 11);
		TraceIn("LPAREN", 11);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:56:7: ( '-(' )
			DebugEnterAlt(1);
			// ./find/Find.g:56:9: '-('
			{
			DebugLocation(56, 9);
			Match("-("); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 11);
			LeaveRule("LPAREN", 11);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 12);
		TraceIn("RPAREN", 12);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:57:7: ( '-)' )
			DebugEnterAlt(1);
			// ./find/Find.g:57:10: '-)'
			{
			DebugLocation(57, 10);
			Match("-)"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 12);
			LeaveRule("RPAREN", 12);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 13);
		TraceIn("AND", 13);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:58:4: ( '-AND' | '-and' | '-&&' )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0=='-'))
			{
				switch (input.LA(2))
				{
				case 'A':
					{
					alt1 = 1;
					}
					break;
				case 'a':
					{
					alt1 = 2;
					}
					break;
				case '&':
					{
					alt1 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 1, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:58:7: '-AND'
				{
				DebugLocation(58, 7);
				Match("-AND"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:58:15: '-and'
				{
				DebugLocation(58, 15);
				Match("-and"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:58:24: '-&&'
				{
				DebugLocation(58, 24);
				Match("-&&"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 13);
			LeaveRule("AND", 13);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 14);
		TraceIn("OR", 14);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:59:3: ( '-OR' | '-or' | '-||' )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0=='-'))
			{
				switch (input.LA(2))
				{
				case 'O':
					{
					alt2 = 1;
					}
					break;
				case 'o':
					{
					alt2 = 2;
					}
					break;
				case '|':
					{
					alt2 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:59:6: '-OR'
				{
				DebugLocation(59, 6);
				Match("-OR"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:59:14: '-or'
				{
				DebugLocation(59, 14);
				Match("-or"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:59:21: '-||'
				{
				DebugLocation(59, 21);
				Match("-||"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 14);
			LeaveRule("OR", 14);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 15);
		TraceIn("NOT", 15);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:60:5: ( '-!' | '-NOT' | '-not' )
			int alt3=3;
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0=='-'))
			{
				switch (input.LA(2))
				{
				case '!':
					{
					alt3 = 1;
					}
					break;
				case 'N':
					{
					alt3 = 2;
					}
					break;
				case 'n':
					{
					alt3 = 3;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 3, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:60:8: '-!'
				{
				DebugLocation(60, 8);
				Match("-!"); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:60:15: '-NOT'
				{
				DebugLocation(60, 15);
				Match("-NOT"); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:60:24: '-not'
				{
				DebugLocation(60, 24);
				Match("-not"); 


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 15);
			LeaveRule("NOT", 15);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_STRING_LITERAL();
	partial void LeaveRule_STRING_LITERAL();

	// $ANTLR start "STRING_LITERAL"
	[GrammarRule("STRING_LITERAL")]
	private void mSTRING_LITERAL()
	{
		EnterRule_STRING_LITERAL();
		EnterRule("STRING_LITERAL", 16);
		TraceIn("STRING_LITERAL", 16);
		try
		{
			int _type = STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:62:2: ( '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"' )
			DebugEnterAlt(1);
			// ./find/Find.g:62:4: '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"'
			{
			DebugLocation(62, 4);
			Match('\"'); 
			DebugLocation(62, 8);
			// ./find/Find.g:62:8: ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0=='\\'))
				{
					alt4 = 1;
				}
				else if (((LA4_0>='\u0000' && LA4_0<='\t')||(LA4_0>='\u000B' && LA4_0<='\f')||(LA4_0>='\u000E' && LA4_0<='!')||(LA4_0>='#' && LA4_0<='[')||(LA4_0>=']' && LA4_0<='\uFFFF')))
				{
					alt4 = 2;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:62:9: ESC
					{
					DebugLocation(62, 9);
					mESC(); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// ./find/Find.g:62:13: ~ ( '\"' | '\\\\' | '\\n' | '\\r' )
					{
					DebugLocation(62, 13);
					input.Consume();


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(62, 37);
			Match('\"'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL", 16);
			LeaveRule("STRING_LITERAL", 16);
			LeaveRule_STRING_LITERAL();
		}
	}
	// $ANTLR end "STRING_LITERAL"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	protected void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 17);
		TraceIn("ESC", 17);
		try
		{
			int _type = ESC;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:75:2: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? ) )
			DebugEnterAlt(1);
			// ./find/Find.g:75:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? )
			{
			DebugLocation(75, 4);
			Match('\\'); 
			DebugLocation(76, 3);
			// ./find/Find.g:76:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )? | '4' .. '7' ( '0' .. '7' )? )
			int alt9=11;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case 'n':
				{
				alt9 = 1;
				}
				break;
			case 'r':
				{
				alt9 = 2;
				}
				break;
			case 't':
				{
				alt9 = 3;
				}
				break;
			case 'b':
				{
				alt9 = 4;
				}
				break;
			case 'f':
				{
				alt9 = 5;
				}
				break;
			case '\"':
				{
				alt9 = 6;
				}
				break;
			case '\'':
				{
				alt9 = 7;
				}
				break;
			case '\\':
				{
				alt9 = 8;
				}
				break;
			case 'u':
				{
				alt9 = 9;
				}
				break;
			case '0':
			case '1':
			case '2':
			case '3':
				{
				alt9 = 10;
				}
				break;
			case '4':
			case '5':
			case '6':
			case '7':
				{
				alt9 = 11;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/Find.g:76:5: 'n'
				{
				DebugLocation(76, 5);
				Match('n'); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/Find.g:77:5: 'r'
				{
				DebugLocation(77, 5);
				Match('r'); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/Find.g:78:5: 't'
				{
				DebugLocation(78, 5);
				Match('t'); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ./find/Find.g:79:5: 'b'
				{
				DebugLocation(79, 5);
				Match('b'); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ./find/Find.g:80:5: 'f'
				{
				DebugLocation(80, 5);
				Match('f'); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ./find/Find.g:81:5: '\"'
				{
				DebugLocation(81, 5);
				Match('\"'); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ./find/Find.g:82:5: '\\''
				{
				DebugLocation(82, 5);
				Match('\''); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ./find/Find.g:83:5: '\\\\'
				{
				DebugLocation(83, 5);
				Match('\\'); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// ./find/Find.g:84:5: ( 'u' )+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
				{
				DebugLocation(84, 5);
				// ./find/Find.g:84:5: ( 'u' )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if ((LA5_0=='u'))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:84:6: 'u'
						{
						DebugLocation(84, 6);
						Match('u'); 

						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(84, 12);
				mHEX_DIGIT(); 
				DebugLocation(84, 22);
				mHEX_DIGIT(); 
				DebugLocation(84, 32);
				mHEX_DIGIT(); 
				DebugLocation(84, 42);
				mHEX_DIGIT(); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// ./find/Find.g:85:5: '0' .. '3' ( '0' .. '7' ( '0' .. '7' )? )?
				{
				DebugLocation(85, 5);
				MatchRange('0','3'); 
				DebugLocation(86, 4);
				// ./find/Find.g:86:4: ( '0' .. '7' ( '0' .. '7' )? )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if (((LA7_0>='0' && LA7_0<='7')))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:90:6: '0' .. '7' ( '0' .. '7' )?
					{
					DebugLocation(90, 6);
					MatchRange('0','7'); 
					DebugLocation(91, 5);
					// ./find/Find.g:91:5: ( '0' .. '7' )?
					int alt6=2;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					int LA6_0 = input.LA(1);

					if (((LA6_0>='0' && LA6_0<='7')))
					{
						alt6 = 1;
					}
					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// ./find/Find.g:
						{
						DebugLocation(91, 5);
						input.Consume();


						}
						break;

					}
					} finally { DebugExitSubRule(6); }


					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// ./find/Find.g:98:5: '4' .. '7' ( '0' .. '7' )?
				{
				DebugLocation(98, 5);
				MatchRange('4','7'); 
				DebugLocation(99, 4);
				// ./find/Find.g:99:4: ( '0' .. '7' )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if (((LA8_0>='0' && LA8_0<='7')))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(99, 4);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ESC", 17);
			LeaveRule("ESC", 17);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_HEX_DIGIT();
	partial void LeaveRule_HEX_DIGIT();

	// $ANTLR start "HEX_DIGIT"
	[GrammarRule("HEX_DIGIT")]
	protected void mHEX_DIGIT()
	{
		EnterRule_HEX_DIGIT();
		EnterRule("HEX_DIGIT", 18);
		TraceIn("HEX_DIGIT", 18);
		try
		{
			int _type = HEX_DIGIT;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:112:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
			DebugEnterAlt(1);
			// ./find/Find.g:
			{
			DebugLocation(112, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_DIGIT", 18);
			LeaveRule("HEX_DIGIT", 18);
			LeaveRule_HEX_DIGIT();
		}
	}
	// $ANTLR end "HEX_DIGIT"

	partial void EnterRule_UNQOTED_LITERAL();
	partial void LeaveRule_UNQOTED_LITERAL();

	// $ANTLR start "UNQOTED_LITERAL"
	[GrammarRule("UNQOTED_LITERAL")]
	private void mUNQOTED_LITERAL()
	{
		EnterRule_UNQOTED_LITERAL();
		EnterRule("UNQOTED_LITERAL", 19);
		TraceIn("UNQOTED_LITERAL", 19);
		try
		{
			int _type = UNQOTED_LITERAL;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:114:2: ( (~ ( ' ' | '-' | '=' ) )* )
			DebugEnterAlt(1);
			// ./find/Find.g:114:4: (~ ( ' ' | '-' | '=' ) )*
			{
			DebugLocation(114, 4);
			// ./find/Find.g:114:4: (~ ( ' ' | '-' | '=' ) )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if (((LA10_0>='\u0000' && LA10_0<='\u001F')||(LA10_0>='!' && LA10_0<=',')||(LA10_0>='.' && LA10_0<='<')||(LA10_0>='>' && LA10_0<='\uFFFF')))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(114, 4);
					input.Consume();


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNQOTED_LITERAL", 19);
			LeaveRule("UNQOTED_LITERAL", 19);
			LeaveRule_UNQOTED_LITERAL();
		}
	}
	// $ANTLR end "UNQOTED_LITERAL"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 20);
		TraceIn("EQ", 20);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:115:4: ( '=' )
			DebugEnterAlt(1);
			// ./find/Find.g:115:6: '='
			{
			DebugLocation(115, 6);
			Match('='); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 20);
			LeaveRule("EQ", 20);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 21);
		TraceIn("WS", 21);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// ./find/Find.g:116:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// ./find/Find.g:116:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
			{
			DebugLocation(116, 6);
			// ./find/Find.g:116:6: ( ' ' | '\\t' | '\\r' | '\\n' )+
			int cnt11=0;
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if (((LA11_0>='\t' && LA11_0<='\n')||LA11_0=='\r'||LA11_0==' '))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/Find.g:
					{
					DebugLocation(116, 6);
					input.Consume();


					}
					break;

				default:
					if (cnt11 >= 1)
						goto loop11;

					EarlyExitException eee11 = new EarlyExitException( 11, input );
					DebugRecognitionException(eee11);
					throw eee11;
				}
				cnt11++;
			}
			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(116, 34);
			_channel = Hidden ;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 21);
			LeaveRule("WS", 21);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// ./find/Find.g:1:8: ( T__23 | T__24 | NAME | INAME | REGEX | IREGEX | PATH | TYPE | SIZE | DEPTH | LPAREN | RPAREN | AND | OR | NOT | STRING_LITERAL | ESC | HEX_DIGIT | UNQOTED_LITERAL | EQ | WS )
		int alt12=21;
		try { DebugEnterDecision(12, false);
		try
		{
			alt12 = dfa12.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(12); }
		switch (alt12)
		{
		case 1:
			DebugEnterAlt(1);
			// ./find/Find.g:1:10: T__23
			{
			DebugLocation(1, 10);
			mT__23(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// ./find/Find.g:1:16: T__24
			{
			DebugLocation(1, 16);
			mT__24(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// ./find/Find.g:1:22: NAME
			{
			DebugLocation(1, 22);
			mNAME(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// ./find/Find.g:1:27: INAME
			{
			DebugLocation(1, 27);
			mINAME(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// ./find/Find.g:1:33: REGEX
			{
			DebugLocation(1, 33);
			mREGEX(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// ./find/Find.g:1:39: IREGEX
			{
			DebugLocation(1, 39);
			mIREGEX(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// ./find/Find.g:1:46: PATH
			{
			DebugLocation(1, 46);
			mPATH(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// ./find/Find.g:1:51: TYPE
			{
			DebugLocation(1, 51);
			mTYPE(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// ./find/Find.g:1:56: SIZE
			{
			DebugLocation(1, 56);
			mSIZE(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// ./find/Find.g:1:61: DEPTH
			{
			DebugLocation(1, 61);
			mDEPTH(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// ./find/Find.g:1:67: LPAREN
			{
			DebugLocation(1, 67);
			mLPAREN(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// ./find/Find.g:1:74: RPAREN
			{
			DebugLocation(1, 74);
			mRPAREN(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// ./find/Find.g:1:81: AND
			{
			DebugLocation(1, 81);
			mAND(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// ./find/Find.g:1:85: OR
			{
			DebugLocation(1, 85);
			mOR(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// ./find/Find.g:1:88: NOT
			{
			DebugLocation(1, 88);
			mNOT(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// ./find/Find.g:1:92: STRING_LITERAL
			{
			DebugLocation(1, 92);
			mSTRING_LITERAL(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// ./find/Find.g:1:107: ESC
			{
			DebugLocation(1, 107);
			mESC(); 

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// ./find/Find.g:1:111: HEX_DIGIT
			{
			DebugLocation(1, 111);
			mHEX_DIGIT(); 

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// ./find/Find.g:1:121: UNQOTED_LITERAL
			{
			DebugLocation(1, 121);
			mUNQOTED_LITERAL(); 

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// ./find/Find.g:1:137: EQ
			{
			DebugLocation(1, 137);
			mEQ(); 

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// ./find/Find.g:1:140: WS
			{
			DebugLocation(1, 140);
			mWS(); 

			}
			break;

		}

	}


	#region DFA
	DFA12 dfa12;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa12 = new DFA12(this, SpecialStateTransition12);
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x1\x8\x1\xB\x1\xC\x1\xFFFF\x2\x8\x1\x28\x1\x8\x11\xFFFF\x2\x8\x1\x1C"+
			"\x1\xFFFF\x8\x37\x1\x8\x2\x37\x4\xFFFF\xB\x8\x1\xFFFF\x1\x8\x2\x37\x4"+
			"\x8\x1\x37\x4\x8\x1\x37\x1\x8";
		private const string DFA12_eofS =
			"\x46\xFFFF";
		private const string DFA12_minS =
			"\x1\x9\x2\x0\x1\x21\x1\x0\x1\x22\x1\x0\x1\x9\x5\xFFFF\x1\x61\x1\x6E\xA"+
			"\xFFFF\x1\x22\x2\x0\x1\xFFFF\x8\x0\x1\x30\x2\x0\x4\xFFFF\x8\x0\x1\x30"+
			"\x2\x0\x1\xFFFF\x1\x30\x2\x0\x1\x30\x2\x0\x1\x30\x1\x0\x1\x30\x1\x0\x2"+
			"\x30\x2\x0";
		private const string DFA12_maxS =
			"\x1\x66\x2\xFFFF\x1\x7C\x1\xFFFF\x1\x75\x1\xFFFF\x1\x20\x5\xFFFF\x1\x6F"+
			"\x1\x72\xA\xFFFF\x1\x75\x2\xFFFF\x1\xFFFF\x8\xFFFF\x1\x75\x2\xFFFF\x4"+
			"\xFFFF\x8\xFFFF\x1\x75\x2\xFFFF\x1\xFFFF\x1\x66\x2\xFFFF\x1\x66\x2\xFFFF"+
			"\x1\x66\x1\xFFFF\x1\x66\x1\xFFFF\x2\x66\x2\xFFFF";
		private const string DFA12_acceptS =
			"\x8\xFFFF\x1\x13\x1\x14\x1\x15\x1\x1\x1\x2\x2\xFFFF\x1\x5\x1\x7\x1\x8"+
			"\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x3\xFFFF\x1\x10\xB\xFFFF\x1"+
			"\x12\x1\x3\x1\x4\x1\x6\xB\xFFFF\x1\x11\xE\xFFFF";
		private const string DFA12_specialS =
			"\x1\xFFFF\x1\x17\x1\x15\x1\xFFFF\x1\x7\x1\xFFFF\x1\x13\x13\xFFFF\x1\x16"+
			"\x1\x3\x1\xFFFF\x1\x20\x1\x1A\x1\x19\x1\x1C\x1\x1B\x1\xD\x1\xF\x1\xB"+
			"\x1\xFFFF\x1\x1\x1\x1D\x4\xFFFF\x1\xC\x1\x10\x1\xE\x1\x6\x1\x5\x1\xA"+
			"\x1\x8\x1\x1F\x1\xFFFF\x1\x21\x1\x11\x2\xFFFF\x1\x12\x1\x4\x1\xFFFF\x1"+
			"\x0\x1\x9\x1\xFFFF\x1\x14\x1\xFFFF\x1\x1E\x2\xFFFF\x1\x18\x1\x2}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x2\x7\x2\xFFFF\x1\x7\x12\xFFFF\x1\xA\x1\xFFFF\x1\x4\xA\xFFFF\x1\x3"+
				"\x2\xFFFF\xA\x6\x3\xFFFF\x1\x9\x3\xFFFF\x6\x6\x15\xFFFF\x1\x5\x4\xFFFF"+
				"\x3\x6\x1\x1\x1\x6\x1\x2",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x1\x18\x4\xFFFF\x1\x16\x1\xFFFF\x1\x14\x1\x15\x17\xFFFF\x1\x16\xC"+
				"\xFFFF\x1\x18\x1\x17\x11\xFFFF\x1\x16\x2\xFFFF\x1\x13\x4\xFFFF\x1\xE"+
				"\x4\xFFFF\x1\xD\x1\x17\x1\x10\x1\xFFFF\x1\xF\x1\x12\x1\x11\x7\xFFFF"+
				"\x1\x17",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\x1\x22\x4\xFFFF\x1\x23\x8\xFFFF\x4\x26\x4\x27\x24\xFFFF\x1\x24\x5"+
				"\xFFFF\x1\x20\x3\xFFFF\x1\x21\x7\xFFFF\x1\x1D\x3\xFFFF\x1\x1E\x1\xFFFF"+
				"\x1\x1F\x1\x25",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x2\x7\x2\xFFFF\x1\x7\x12\xFFFF\x1\xA",
				"",
				"",
				"",
				"",
				"",
				"\x1\x29\xD\xFFFF\x1\x18",
				"\x1\x2A\x3\xFFFF\x1\x2B",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x31\x4\xFFFF\x1\x32\x8\xFFFF\x4\x35\x4\x36\x24\xFFFF\x1\x33\x5"+
				"\xFFFF\x1\x2F\x3\xFFFF\x1\x30\x7\xFFFF\x1\x2C\x3\xFFFF\x1\x2D\x1\xFFFF"+
				"\x1\x2E\x1\x34",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\xA\x38\x7\xFFFF\x6\x38\x1A\xFFFF\x6\x38\xE\xFFFF\x1\x25",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\x2\x8\x8\x39\x5\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\x2\x8\x8\x3A\x5\x8\x1\xFFFF\xFFC2\x8",
				"",
				"",
				"",
				"",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x3B\x7\xFFFF\x6\x3B\x1A\xFFFF\x6\x3B\xE\xFFFF\x1\x34",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\x2\x1A\x8\x3C\x5\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\x2\x1A\x8\x3D\x5\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"",
				"\xA\x3E\x7\xFFFF\x6\x3E\x1A\xFFFF\x6\x3E",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\x2\x8\x8\x3F\x5\x8\x1\xFFFF\xFFC2\x8",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\xA\x40\x7\xFFFF\x6\x40\x1A\xFFFF\x6\x40",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\x2\x1A\x8\x41\x5\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x42\x7\xFFFF\x6\x42\x1A\xFFFF\x6\x42",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\xA\x43\x7\xFFFF\x6\x43\x1A\xFFFF\x6\x43",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A",
				"\xA\x44\x7\xFFFF\x6\x44\x1A\xFFFF\x6\x44",
				"\xA\x45\x7\xFFFF\x6\x45\x1A\xFFFF\x6\x45",
				"\x20\x8\x1\xFFFF\xC\x8\x1\xFFFF\xF\x8\x1\xFFFF\xFFC2\x8",
				"\xA\x1A\x1\xFFFF\x2\x1A\x1\xFFFF\x12\x1A\x1\x1C\x1\x1A\x1\x1B\xA\x1A"+
				"\x1\x1C\xF\x1A\x1\x1C\x1E\x1A\x1\x19\xFFA3\x1A"
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( T__23 | T__24 | NAME | INAME | REGEX | IREGEX | PATH | TYPE | SIZE | DEPTH | LPAREN | RPAREN | AND | OR | NOT | STRING_LITERAL | ESC | HEX_DIGIT | UNQOTED_LITERAL | EQ | WS );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition12(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA12_60 = input.LA(1);

				s = -1;
				if (((LA12_60>='0' && LA12_60<='7'))) {s = 65;}

				else if ((LA12_60=='\"')) {s = 27;}

				else if ((LA12_60=='\\')) {s = 25;}

				else if (((LA12_60>='\u0000' && LA12_60<='\t')||(LA12_60>='\u000B' && LA12_60<='\f')||(LA12_60>='\u000E' && LA12_60<='\u001F')||LA12_60=='!'||(LA12_60>='#' && LA12_60<=',')||(LA12_60>='.' && LA12_60<='/')||(LA12_60>='8' && LA12_60<='<')||(LA12_60>='>' && LA12_60<='[')||(LA12_60>=']' && LA12_60<='\uFFFF'))) {s = 26;}

				else if ((LA12_60==' '||LA12_60=='-'||LA12_60=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 1:
				int LA12_38 = input.LA(1);

				s = -1;
				if (((LA12_38>='0' && LA12_38<='7'))) {s = 57;}

				else if (((LA12_38>='\u0000' && LA12_38<='\u001F')||(LA12_38>='!' && LA12_38<=',')||(LA12_38>='.' && LA12_38<='/')||(LA12_38>='8' && LA12_38<='<')||(LA12_38>='>' && LA12_38<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 2:
				int LA12_69 = input.LA(1);

				s = -1;
				if ((LA12_69=='\"')) {s = 27;}

				else if ((LA12_69=='\\')) {s = 25;}

				else if (((LA12_69>='\u0000' && LA12_69<='\t')||(LA12_69>='\u000B' && LA12_69<='\f')||(LA12_69>='\u000E' && LA12_69<='\u001F')||LA12_69=='!'||(LA12_69>='#' && LA12_69<=',')||(LA12_69>='.' && LA12_69<='<')||(LA12_69>='>' && LA12_69<='[')||(LA12_69>=']' && LA12_69<='\uFFFF'))) {s = 26;}

				else if ((LA12_69==' '||LA12_69=='-'||LA12_69=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 3:
				int LA12_27 = input.LA(1);

				s = -1;
				if (((LA12_27>='\u0000' && LA12_27<='\u001F')||(LA12_27>='!' && LA12_27<=',')||(LA12_27>='.' && LA12_27<='<')||(LA12_27>='>' && LA12_27<='\uFFFF'))) {s = 8;}

				else s = 28;

				if (s >= 0) return s;
				break;

			case 4:
				int LA12_58 = input.LA(1);

				s = -1;
				if (((LA12_58>='\u0000' && LA12_58<='\u001F')||(LA12_58>='!' && LA12_58<=',')||(LA12_58>='.' && LA12_58<='<')||(LA12_58>='>' && LA12_58<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 5:
				int LA12_48 = input.LA(1);

				s = -1;
				if ((LA12_48=='\"')) {s = 27;}

				else if ((LA12_48=='\\')) {s = 25;}

				else if (((LA12_48>='\u0000' && LA12_48<='\t')||(LA12_48>='\u000B' && LA12_48<='\f')||(LA12_48>='\u000E' && LA12_48<='\u001F')||LA12_48=='!'||(LA12_48>='#' && LA12_48<=',')||(LA12_48>='.' && LA12_48<='<')||(LA12_48>='>' && LA12_48<='[')||(LA12_48>=']' && LA12_48<='\uFFFF'))) {s = 26;}

				else if ((LA12_48==' '||LA12_48=='-'||LA12_48=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 6:
				int LA12_47 = input.LA(1);

				s = -1;
				if ((LA12_47=='\"')) {s = 27;}

				else if ((LA12_47=='\\')) {s = 25;}

				else if (((LA12_47>='\u0000' && LA12_47<='\t')||(LA12_47>='\u000B' && LA12_47<='\f')||(LA12_47>='\u000E' && LA12_47<='\u001F')||LA12_47=='!'||(LA12_47>='#' && LA12_47<=',')||(LA12_47>='.' && LA12_47<='<')||(LA12_47>='>' && LA12_47<='[')||(LA12_47>=']' && LA12_47<='\uFFFF'))) {s = 26;}

				else if ((LA12_47==' '||LA12_47=='-'||LA12_47=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 7:
				int LA12_4 = input.LA(1);

				s = -1;
				if ((LA12_4=='\\')) {s = 25;}

				else if (((LA12_4>='\u0000' && LA12_4<='\t')||(LA12_4>='\u000B' && LA12_4<='\f')||(LA12_4>='\u000E' && LA12_4<='\u001F')||LA12_4=='!'||(LA12_4>='#' && LA12_4<=',')||(LA12_4>='.' && LA12_4<='<')||(LA12_4>='>' && LA12_4<='[')||(LA12_4>=']' && LA12_4<='\uFFFF'))) {s = 26;}

				else if ((LA12_4=='\"')) {s = 27;}

				else if ((LA12_4==' '||LA12_4=='-'||LA12_4=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 8:
				int LA12_50 = input.LA(1);

				s = -1;
				if ((LA12_50=='\"')) {s = 27;}

				else if ((LA12_50=='\\')) {s = 25;}

				else if (((LA12_50>='\u0000' && LA12_50<='\t')||(LA12_50>='\u000B' && LA12_50<='\f')||(LA12_50>='\u000E' && LA12_50<='\u001F')||LA12_50=='!'||(LA12_50>='#' && LA12_50<=',')||(LA12_50>='.' && LA12_50<='<')||(LA12_50>='>' && LA12_50<='[')||(LA12_50>=']' && LA12_50<='\uFFFF'))) {s = 26;}

				else if ((LA12_50==' '||LA12_50=='-'||LA12_50=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 9:
				int LA12_61 = input.LA(1);

				s = -1;
				if ((LA12_61=='\"')) {s = 27;}

				else if ((LA12_61=='\\')) {s = 25;}

				else if (((LA12_61>='\u0000' && LA12_61<='\t')||(LA12_61>='\u000B' && LA12_61<='\f')||(LA12_61>='\u000E' && LA12_61<='\u001F')||LA12_61=='!'||(LA12_61>='#' && LA12_61<=',')||(LA12_61>='.' && LA12_61<='<')||(LA12_61>='>' && LA12_61<='[')||(LA12_61>=']' && LA12_61<='\uFFFF'))) {s = 26;}

				else if ((LA12_61==' '||LA12_61=='-'||LA12_61=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 10:
				int LA12_49 = input.LA(1);

				s = -1;
				if ((LA12_49=='\"')) {s = 27;}

				else if ((LA12_49=='\\')) {s = 25;}

				else if (((LA12_49>='\u0000' && LA12_49<='\t')||(LA12_49>='\u000B' && LA12_49<='\f')||(LA12_49>='\u000E' && LA12_49<='\u001F')||LA12_49=='!'||(LA12_49>='#' && LA12_49<=',')||(LA12_49>='.' && LA12_49<='<')||(LA12_49>='>' && LA12_49<='[')||(LA12_49>=']' && LA12_49<='\uFFFF'))) {s = 26;}

				else if ((LA12_49==' '||LA12_49=='-'||LA12_49=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 11:
				int LA12_36 = input.LA(1);

				s = -1;
				if (((LA12_36>='\u0000' && LA12_36<='\u001F')||(LA12_36>='!' && LA12_36<=',')||(LA12_36>='.' && LA12_36<='<')||(LA12_36>='>' && LA12_36<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 12:
				int LA12_44 = input.LA(1);

				s = -1;
				if ((LA12_44=='\"')) {s = 27;}

				else if ((LA12_44=='\\')) {s = 25;}

				else if (((LA12_44>='\u0000' && LA12_44<='\t')||(LA12_44>='\u000B' && LA12_44<='\f')||(LA12_44>='\u000E' && LA12_44<='\u001F')||LA12_44=='!'||(LA12_44>='#' && LA12_44<=',')||(LA12_44>='.' && LA12_44<='<')||(LA12_44>='>' && LA12_44<='[')||(LA12_44>=']' && LA12_44<='\uFFFF'))) {s = 26;}

				else if ((LA12_44==' '||LA12_44=='-'||LA12_44=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 13:
				int LA12_34 = input.LA(1);

				s = -1;
				if (((LA12_34>='\u0000' && LA12_34<='\u001F')||(LA12_34>='!' && LA12_34<=',')||(LA12_34>='.' && LA12_34<='<')||(LA12_34>='>' && LA12_34<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 14:
				int LA12_46 = input.LA(1);

				s = -1;
				if ((LA12_46=='\"')) {s = 27;}

				else if ((LA12_46=='\\')) {s = 25;}

				else if (((LA12_46>='\u0000' && LA12_46<='\t')||(LA12_46>='\u000B' && LA12_46<='\f')||(LA12_46>='\u000E' && LA12_46<='\u001F')||LA12_46=='!'||(LA12_46>='#' && LA12_46<=',')||(LA12_46>='.' && LA12_46<='<')||(LA12_46>='>' && LA12_46<='[')||(LA12_46>=']' && LA12_46<='\uFFFF'))) {s = 26;}

				else if ((LA12_46==' '||LA12_46=='-'||LA12_46=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 15:
				int LA12_35 = input.LA(1);

				s = -1;
				if (((LA12_35>='\u0000' && LA12_35<='\u001F')||(LA12_35>='!' && LA12_35<=',')||(LA12_35>='.' && LA12_35<='<')||(LA12_35>='>' && LA12_35<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 16:
				int LA12_45 = input.LA(1);

				s = -1;
				if ((LA12_45=='\"')) {s = 27;}

				else if ((LA12_45=='\\')) {s = 25;}

				else if (((LA12_45>='\u0000' && LA12_45<='\t')||(LA12_45>='\u000B' && LA12_45<='\f')||(LA12_45>='\u000E' && LA12_45<='\u001F')||LA12_45=='!'||(LA12_45>='#' && LA12_45<=',')||(LA12_45>='.' && LA12_45<='<')||(LA12_45>='>' && LA12_45<='[')||(LA12_45>=']' && LA12_45<='\uFFFF'))) {s = 26;}

				else if ((LA12_45==' '||LA12_45=='-'||LA12_45=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 17:
				int LA12_54 = input.LA(1);

				s = -1;
				if (((LA12_54>='0' && LA12_54<='7'))) {s = 61;}

				else if ((LA12_54=='\"')) {s = 27;}

				else if ((LA12_54=='\\')) {s = 25;}

				else if (((LA12_54>='\u0000' && LA12_54<='\t')||(LA12_54>='\u000B' && LA12_54<='\f')||(LA12_54>='\u000E' && LA12_54<='\u001F')||LA12_54=='!'||(LA12_54>='#' && LA12_54<=',')||(LA12_54>='.' && LA12_54<='/')||(LA12_54>='8' && LA12_54<='<')||(LA12_54>='>' && LA12_54<='[')||(LA12_54>=']' && LA12_54<='\uFFFF'))) {s = 26;}

				else if ((LA12_54==' '||LA12_54=='-'||LA12_54=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 18:
				int LA12_57 = input.LA(1);

				s = -1;
				if (((LA12_57>='0' && LA12_57<='7'))) {s = 63;}

				else if (((LA12_57>='\u0000' && LA12_57<='\u001F')||(LA12_57>='!' && LA12_57<=',')||(LA12_57>='.' && LA12_57<='/')||(LA12_57>='8' && LA12_57<='<')||(LA12_57>='>' && LA12_57<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 19:
				int LA12_6 = input.LA(1);

				s = -1;
				if (((LA12_6>='\u0000' && LA12_6<='\u001F')||(LA12_6>='!' && LA12_6<=',')||(LA12_6>='.' && LA12_6<='<')||(LA12_6>='>' && LA12_6<='\uFFFF'))) {s = 8;}

				else s = 40;

				if (s >= 0) return s;
				break;

			case 20:
				int LA12_63 = input.LA(1);

				s = -1;
				if (((LA12_63>='\u0000' && LA12_63<='\u001F')||(LA12_63>='!' && LA12_63<=',')||(LA12_63>='.' && LA12_63<='<')||(LA12_63>='>' && LA12_63<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 21:
				int LA12_2 = input.LA(1);

				s = -1;
				if (((LA12_2>='\u0000' && LA12_2<='\u001F')||(LA12_2>='!' && LA12_2<=',')||(LA12_2>='.' && LA12_2<='<')||(LA12_2>='>' && LA12_2<='\uFFFF'))) {s = 8;}

				else s = 12;

				if (s >= 0) return s;
				break;

			case 22:
				int LA12_26 = input.LA(1);

				s = -1;
				if ((LA12_26=='\"')) {s = 27;}

				else if ((LA12_26=='\\')) {s = 25;}

				else if (((LA12_26>='\u0000' && LA12_26<='\t')||(LA12_26>='\u000B' && LA12_26<='\f')||(LA12_26>='\u000E' && LA12_26<='\u001F')||LA12_26=='!'||(LA12_26>='#' && LA12_26<=',')||(LA12_26>='.' && LA12_26<='<')||(LA12_26>='>' && LA12_26<='[')||(LA12_26>=']' && LA12_26<='\uFFFF'))) {s = 26;}

				else if ((LA12_26==' '||LA12_26=='-'||LA12_26=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 23:
				int LA12_1 = input.LA(1);

				s = -1;
				if (((LA12_1>='\u0000' && LA12_1<='\u001F')||(LA12_1>='!' && LA12_1<=',')||(LA12_1>='.' && LA12_1<='<')||(LA12_1>='>' && LA12_1<='\uFFFF'))) {s = 8;}

				else s = 11;

				if (s >= 0) return s;
				break;

			case 24:
				int LA12_68 = input.LA(1);

				s = -1;
				if (((LA12_68>='\u0000' && LA12_68<='\u001F')||(LA12_68>='!' && LA12_68<=',')||(LA12_68>='.' && LA12_68<='<')||(LA12_68>='>' && LA12_68<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 25:
				int LA12_31 = input.LA(1);

				s = -1;
				if (((LA12_31>='\u0000' && LA12_31<='\u001F')||(LA12_31>='!' && LA12_31<=',')||(LA12_31>='.' && LA12_31<='<')||(LA12_31>='>' && LA12_31<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 26:
				int LA12_30 = input.LA(1);

				s = -1;
				if (((LA12_30>='\u0000' && LA12_30<='\u001F')||(LA12_30>='!' && LA12_30<=',')||(LA12_30>='.' && LA12_30<='<')||(LA12_30>='>' && LA12_30<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 27:
				int LA12_33 = input.LA(1);

				s = -1;
				if (((LA12_33>='\u0000' && LA12_33<='\u001F')||(LA12_33>='!' && LA12_33<=',')||(LA12_33>='.' && LA12_33<='<')||(LA12_33>='>' && LA12_33<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 28:
				int LA12_32 = input.LA(1);

				s = -1;
				if (((LA12_32>='\u0000' && LA12_32<='\u001F')||(LA12_32>='!' && LA12_32<=',')||(LA12_32>='.' && LA12_32<='<')||(LA12_32>='>' && LA12_32<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 29:
				int LA12_39 = input.LA(1);

				s = -1;
				if (((LA12_39>='0' && LA12_39<='7'))) {s = 58;}

				else if (((LA12_39>='\u0000' && LA12_39<='\u001F')||(LA12_39>='!' && LA12_39<=',')||(LA12_39>='.' && LA12_39<='/')||(LA12_39>='8' && LA12_39<='<')||(LA12_39>='>' && LA12_39<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 30:
				int LA12_65 = input.LA(1);

				s = -1;
				if ((LA12_65=='\"')) {s = 27;}

				else if ((LA12_65=='\\')) {s = 25;}

				else if (((LA12_65>='\u0000' && LA12_65<='\t')||(LA12_65>='\u000B' && LA12_65<='\f')||(LA12_65>='\u000E' && LA12_65<='\u001F')||LA12_65=='!'||(LA12_65>='#' && LA12_65<=',')||(LA12_65>='.' && LA12_65<='<')||(LA12_65>='>' && LA12_65<='[')||(LA12_65>=']' && LA12_65<='\uFFFF'))) {s = 26;}

				else if ((LA12_65==' '||LA12_65=='-'||LA12_65=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 31:
				int LA12_51 = input.LA(1);

				s = -1;
				if ((LA12_51=='\"')) {s = 27;}

				else if ((LA12_51=='\\')) {s = 25;}

				else if (((LA12_51>='\u0000' && LA12_51<='\t')||(LA12_51>='\u000B' && LA12_51<='\f')||(LA12_51>='\u000E' && LA12_51<='\u001F')||LA12_51=='!'||(LA12_51>='#' && LA12_51<=',')||(LA12_51>='.' && LA12_51<='<')||(LA12_51>='>' && LA12_51<='[')||(LA12_51>=']' && LA12_51<='\uFFFF'))) {s = 26;}

				else if ((LA12_51==' '||LA12_51=='-'||LA12_51=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;

			case 32:
				int LA12_29 = input.LA(1);

				s = -1;
				if (((LA12_29>='\u0000' && LA12_29<='\u001F')||(LA12_29>='!' && LA12_29<=',')||(LA12_29>='.' && LA12_29<='<')||(LA12_29>='>' && LA12_29<='\uFFFF'))) {s = 8;}

				else s = 55;

				if (s >= 0) return s;
				break;

			case 33:
				int LA12_53 = input.LA(1);

				s = -1;
				if (((LA12_53>='0' && LA12_53<='7'))) {s = 60;}

				else if ((LA12_53=='\"')) {s = 27;}

				else if ((LA12_53=='\\')) {s = 25;}

				else if (((LA12_53>='\u0000' && LA12_53<='\t')||(LA12_53>='\u000B' && LA12_53<='\f')||(LA12_53>='\u000E' && LA12_53<='\u001F')||LA12_53=='!'||(LA12_53>='#' && LA12_53<=',')||(LA12_53>='.' && LA12_53<='/')||(LA12_53>='8' && LA12_53<='<')||(LA12_53>='>' && LA12_53<='[')||(LA12_53>=']' && LA12_53<='\uFFFF'))) {s = 26;}

				else if ((LA12_53==' '||LA12_53=='-'||LA12_53=='=')) {s = 28;}

				else s = 8;

				if (s >= 0) return s;
				break;
		}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 12, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
 
	#endregion

}

} // namespace  find 
