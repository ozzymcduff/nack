//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 ./find/FindEval.g 2012-12-27 00:06:38

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using Matcher=System.Func<string,find.find.Type,bool>;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  find 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class FindEval : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "DEPTH", "EQ", "ESC", "HEX_DIGIT", "INAME", "INTEGER", "IREGEX", "LPAREN", "NAME", "NOT", "OR", "REGEX", "RPAREN", "SIZE", "SIZEPOSTFIX", "STRING_LITERAL", "TYPE", "UNQOTED_LITERAL", "WS", "'d'", "'f'", "'t'"
	};
	public const int EOF=-1;
	public const int T__24=24;
	public const int T__25=25;
	public const int AND=4;
	public const int DEPTH=5;
	public const int EQ=6;
	public const int ESC=7;
	public const int HEX_DIGIT=8;
	public const int INAME=9;
	public const int INTEGER=10;
	public const int IREGEX=11;
	public const int LPAREN=12;
	public const int NAME=13;
	public const int NOT=14;
	public const int OR=15;
	public const int REGEX=16;
	public const int RPAREN=17;
	public const int SIZE=18;
	public const int SIZEPOSTFIX=19;
	public const int STRING_LITERAL=20;
	public const int TYPE=21;
	public const int UNQOTED_LITERAL=22;
	public const int WS=23;
	public const int T__26=26;

	public FindEval(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public FindEval(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return FindEval.tokenNames; } }
	public override string GrammarFileName { get { return "./find/FindEval.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_commandline();
	partial void LeaveRule_commandline();

	// $ANTLR start "commandline"
	// ./find/FindEval.g:13:1: commandline : ( expression )* ;
	[GrammarRule("commandline")]
	private void commandline()
	{
		EnterRule_commandline();
		EnterRule("commandline", 1);
		TraceIn("commandline", 1);
		try { DebugEnterRule(GrammarFileName, "commandline");
		DebugLocation(13, 14);
		try
		{
			// ./find/FindEval.g:14:2: ( ( expression )* )
			DebugEnterAlt(1);
			// ./find/FindEval.g:14:4: ( expression )*
			{
			DebugLocation(14, 4);
			// ./find/FindEval.g:14:4: ( expression )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>=AND && LA1_0<=DEPTH)||LA1_0==INAME||(LA1_0>=IREGEX && LA1_0<=REGEX)||LA1_0==SIZE||LA1_0==TYPE))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// ./find/FindEval.g:14:4: expression
					{
					DebugLocation(14, 4);
					PushFollow(Follow._expression_in_commandline48);
					expression();
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("commandline", 1);
			LeaveRule("commandline", 1);
			LeaveRule_commandline();
		}
		DebugLocation(14, 14);
		} finally { DebugExitRule(GrammarFileName, "commandline"); }
		return;

	}
	// $ANTLR end "commandline"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// ./find/FindEval.g:16:1: expression : (e= expr |n= other );
	[GrammarRule("expression")]
	private void expression()
	{
		EnterRule_expression();
		EnterRule("expression", 2);
		TraceIn("expression", 2);
		Matcher e = default(Matcher);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(16, 10);
		try
		{
			// ./find/FindEval.g:17:2: (e= expr |n= other )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==AND||LA2_0==INAME||(LA2_0>=IREGEX && LA2_0<=REGEX)||LA2_0==SIZE||LA2_0==TYPE))
			{
				alt2 = 1;
			}
			else if ((LA2_0==DEPTH))
			{
				alt2 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/FindEval.g:17:4: e= expr
				{
				DebugLocation(17, 5);
				PushFollow(Follow._expr_in_expression60);
				e=expr();
				PopFollow();

				DebugLocation(17, 11);
				 Add(e);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/FindEval.g:18:4: n= other
				{
				DebugLocation(18, 5);
				PushFollow(Follow._other_in_expression69);
				other();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 2);
			LeaveRule("expression", 2);
			LeaveRule_expression();
		}
		DebugLocation(18, 10);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// ./find/FindEval.g:20:1: expr returns [Matcher value] : ( ^( NOT a= expr ) | ^( OR a= expr b= expr ) | ^( AND a= expr b= expr ) | ^( LPAREN a= expr RPAREN ) | ^( NAME EQ v= val ) | ^( INAME EQ v= val ) | ^( REGEX EQ v= val ) | ^( IREGEX EQ v= val ) | ^( SIZE EQ i= integer p= sizepostfix ) | ^( TYPE EQ t= type ) );
	[GrammarRule("expr")]
	private Matcher expr()
	{
		EnterRule_expr();
		EnterRule("expr", 3);
		TraceIn("expr", 3);
		Matcher value = default(Matcher);


		Matcher a = default(Matcher);
		Matcher b = default(Matcher);
		string v = default(string);
		long i = default(long);
		string p = default(string);
		string t = default(string);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(20, 1);
		try
		{
			// ./find/FindEval.g:21:5: ( ^( NOT a= expr ) | ^( OR a= expr b= expr ) | ^( AND a= expr b= expr ) | ^( LPAREN a= expr RPAREN ) | ^( NAME EQ v= val ) | ^( INAME EQ v= val ) | ^( REGEX EQ v= val ) | ^( IREGEX EQ v= val ) | ^( SIZE EQ i= integer p= sizepostfix ) | ^( TYPE EQ t= type ) )
			int alt3=10;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case NOT:
				{
				alt3 = 1;
				}
				break;
			case OR:
				{
				alt3 = 2;
				}
				break;
			case AND:
				{
				alt3 = 3;
				}
				break;
			case LPAREN:
				{
				alt3 = 4;
				}
				break;
			case NAME:
				{
				alt3 = 5;
				}
				break;
			case INAME:
				{
				alt3 = 6;
				}
				break;
			case REGEX:
				{
				alt3 = 7;
				}
				break;
			case IREGEX:
				{
				alt3 = 8;
				}
				break;
			case SIZE:
				{
				alt3 = 9;
				}
				break;
			case TYPE:
				{
				alt3 = 10;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/FindEval.g:21:9: ^( NOT a= expr )
				{
				DebugLocation(21, 9);
				DebugLocation(21, 11);
				Match(input,NOT,Follow._NOT_in_expr88); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(21, 16);
				PushFollow(Follow._expr_in_expr92);
				a=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(21, 23);
				value = Not(a);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/FindEval.g:22:9: ^( OR a= expr b= expr )
				{
				DebugLocation(22, 9);
				DebugLocation(22, 11);
				Match(input,OR,Follow._OR_in_expr106); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(22, 15);
				PushFollow(Follow._expr_in_expr110);
				a=expr();
				PopFollow();

				DebugLocation(22, 22);
				PushFollow(Follow._expr_in_expr114);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(22, 29);
				value = Or(a,b);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// ./find/FindEval.g:23:9: ^( AND a= expr b= expr )
				{
				DebugLocation(23, 9);
				DebugLocation(23, 11);
				Match(input,AND,Follow._AND_in_expr128); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(23, 16);
				PushFollow(Follow._expr_in_expr132);
				a=expr();
				PopFollow();

				DebugLocation(23, 23);
				PushFollow(Follow._expr_in_expr136);
				b=expr();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(23, 30);
				value = And(a,b);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// ./find/FindEval.g:24:9: ^( LPAREN a= expr RPAREN )
				{
				DebugLocation(24, 9);
				DebugLocation(24, 11);
				Match(input,LPAREN,Follow._LPAREN_in_expr150); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(24, 19);
				PushFollow(Follow._expr_in_expr154);
				a=expr();
				PopFollow();

				DebugLocation(24, 25);
				Match(input,RPAREN,Follow._RPAREN_in_expr156); 

				Match(input, TokenTypes.Up, null); 

				DebugLocation(24, 33);
				value = a;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// ./find/FindEval.g:25:9: ^( NAME EQ v= val )
				{
				DebugLocation(25, 9);
				DebugLocation(25, 11);
				Match(input,NAME,Follow._NAME_in_expr170); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(25, 16);
				Match(input,EQ,Follow._EQ_in_expr172); 
				DebugLocation(25, 20);
				PushFollow(Follow._val_in_expr176);
				v=val();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(25, 28);
				 value = NameMatch(v,false);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// ./find/FindEval.g:26:6: ^( INAME EQ v= val )
				{
				DebugLocation(26, 6);
				DebugLocation(26, 8);
				Match(input,INAME,Follow._INAME_in_expr189); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(26, 14);
				Match(input,EQ,Follow._EQ_in_expr191); 
				DebugLocation(26, 18);
				PushFollow(Follow._val_in_expr195);
				v=val();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(26, 25);
				 value = NameMatch(v,true);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// ./find/FindEval.g:27:6: ^( REGEX EQ v= val )
				{
				DebugLocation(27, 6);
				DebugLocation(27, 8);
				Match(input,REGEX,Follow._REGEX_in_expr207); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(27, 14);
				Match(input,EQ,Follow._EQ_in_expr209); 
				DebugLocation(27, 18);
				PushFollow(Follow._val_in_expr213);
				v=val();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(27, 25);
				 value = RegNameMatch(v,false);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// ./find/FindEval.g:28:6: ^( IREGEX EQ v= val )
				{
				DebugLocation(28, 6);
				DebugLocation(28, 8);
				Match(input,IREGEX,Follow._IREGEX_in_expr225); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(28, 15);
				Match(input,EQ,Follow._EQ_in_expr227); 
				DebugLocation(28, 19);
				PushFollow(Follow._val_in_expr231);
				v=val();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(28, 25);
				 value = RegNameMatch(v,true);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// ./find/FindEval.g:29:6: ^( SIZE EQ i= integer p= sizepostfix )
				{
				DebugLocation(29, 6);
				DebugLocation(29, 8);
				Match(input,SIZE,Follow._SIZE_in_expr242); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(29, 13);
				Match(input,EQ,Follow._EQ_in_expr244); 
				DebugLocation(29, 17);
				PushFollow(Follow._integer_in_expr248);
				i=integer();
				PopFollow();

				DebugLocation(29, 27);
				PushFollow(Follow._sizepostfix_in_expr252);
				p=sizepostfix();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(29, 41);
				value = Size(i,p);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// ./find/FindEval.g:30:6: ^( TYPE EQ t= type )
				{
				DebugLocation(30, 6);
				DebugLocation(30, 8);
				Match(input,TYPE,Follow._TYPE_in_expr263); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(30, 13);
				Match(input,EQ,Follow._EQ_in_expr265); 
				DebugLocation(30, 17);
				PushFollow(Follow._type_in_expr269);
				t=type();
				PopFollow();


				Match(input, TokenTypes.Up, null); 

				DebugLocation(30, 24);
				 value = Type(t);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 3);
			LeaveRule("expr", 3);
			LeaveRule_expr();
		}
		DebugLocation(31, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return value;

	}
	// $ANTLR end "expr"

	partial void EnterRule_other();
	partial void LeaveRule_other();

	// $ANTLR start "other"
	// ./find/FindEval.g:32:1: other : ^( DEPTH EQ i= integer ) ;
	[GrammarRule("other")]
	private void other()
	{
		EnterRule_other();
		EnterRule("other", 4);
		TraceIn("other", 4);
		long i = default(long);

		try { DebugEnterRule(GrammarFileName, "other");
		DebugLocation(32, 37);
		try
		{
			// ./find/FindEval.g:33:2: ( ^( DEPTH EQ i= integer ) )
			DebugEnterAlt(1);
			// ./find/FindEval.g:33:4: ^( DEPTH EQ i= integer )
			{
			DebugLocation(33, 4);
			DebugLocation(33, 6);
			Match(input,DEPTH,Follow._DEPTH_in_other283); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(33, 12);
			Match(input,EQ,Follow._EQ_in_other285); 
			DebugLocation(33, 16);
			PushFollow(Follow._integer_in_other289);
			i=integer();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(33, 26);
			 Depth(i);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("other", 4);
			LeaveRule("other", 4);
			LeaveRule_other();
		}
		DebugLocation(33, 37);
		} finally { DebugExitRule(GrammarFileName, "other"); }
		return;

	}
	// $ANTLR end "other"

	partial void EnterRule_sizepostfix();
	partial void LeaveRule_sizepostfix();

	// $ANTLR start "sizepostfix"
	// ./find/FindEval.g:35:1: sizepostfix returns [string value] : s= SIZEPOSTFIX ;
	[GrammarRule("sizepostfix")]
	private string sizepostfix()
	{
		EnterRule_sizepostfix();
		EnterRule("sizepostfix", 5);
		TraceIn("sizepostfix", 5);
		string value = default(string);


		CommonTree s = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "sizepostfix");
		DebugLocation(35, 33);
		try
		{
			// ./find/FindEval.g:36:2: (s= SIZEPOSTFIX )
			DebugEnterAlt(1);
			// ./find/FindEval.g:36:4: s= SIZEPOSTFIX
			{
			DebugLocation(36, 5);
			s=(CommonTree)Match(input,SIZEPOSTFIX,Follow._SIZEPOSTFIX_in_sizepostfix307); 
			DebugLocation(36, 18);
			value =s.Text;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("sizepostfix", 5);
			LeaveRule("sizepostfix", 5);
			LeaveRule_sizepostfix();
		}
		DebugLocation(36, 33);
		} finally { DebugExitRule(GrammarFileName, "sizepostfix"); }
		return value;

	}
	// $ANTLR end "sizepostfix"

	partial void EnterRule_integer();
	partial void LeaveRule_integer();

	// $ANTLR start "integer"
	// ./find/FindEval.g:38:1: integer returns [long value] : i= INTEGER ;
	[GrammarRule("integer")]
	private long integer()
	{
		EnterRule_integer();
		EnterRule("integer", 6);
		TraceIn("integer", 6);
		long value = default(long);


		CommonTree i = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "integer");
		DebugLocation(38, 42);
		try
		{
			// ./find/FindEval.g:39:2: (i= INTEGER )
			DebugEnterAlt(1);
			// ./find/FindEval.g:39:4: i= INTEGER
			{
			DebugLocation(39, 5);
			i=(CommonTree)Match(input,INTEGER,Follow._INTEGER_in_integer324); 
			DebugLocation(39, 14);
			value =Int64.Parse(i.Text);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("integer", 6);
			LeaveRule("integer", 6);
			LeaveRule_integer();
		}
		DebugLocation(39, 42);
		} finally { DebugExitRule(GrammarFileName, "integer"); }
		return value;

	}
	// $ANTLR end "integer"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// ./find/FindEval.g:41:1: type returns [string value] : t= ( 'f' | 't' ) ;
	[GrammarRule("type")]
	private string type()
	{
		EnterRule_type();
		EnterRule("type", 7);
		TraceIn("type", 7);
		string value = default(string);


		CommonTree t = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(41, 31);
		try
		{
			// ./find/FindEval.g:42:2: (t= ( 'f' | 't' ) )
			DebugEnterAlt(1);
			// ./find/FindEval.g:42:4: t= ( 'f' | 't' )
			{
			DebugLocation(42, 5);

			t=(CommonTree)input.LT(1);
			if ((input.LA(1)>=25 && input.LA(1)<=26))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}

			DebugLocation(42, 16);
			value =t.Text;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("type", 7);
			LeaveRule("type", 7);
			LeaveRule_type();
		}
		DebugLocation(42, 31);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return value;

	}
	// $ANTLR end "type"

	partial void EnterRule_val();
	partial void LeaveRule_val();

	// $ANTLR start "val"
	// ./find/FindEval.g:44:1: val returns [string value] : (q= STRING_LITERAL |v= UNQOTED_LITERAL );
	[GrammarRule("val")]
	private string val()
	{
		EnterRule_val();
		EnterRule("val", 8);
		TraceIn("val", 8);
		string value = default(string);


		CommonTree q = default(CommonTree);
		CommonTree v = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "val");
		DebugLocation(44, 37);
		try
		{
			// ./find/FindEval.g:45:2: (q= STRING_LITERAL |v= UNQOTED_LITERAL )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==STRING_LITERAL))
			{
				alt4 = 1;
			}
			else if ((LA4_0==UNQOTED_LITERAL))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// ./find/FindEval.g:45:4: q= STRING_LITERAL
				{
				DebugLocation(45, 5);
				q=(CommonTree)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_val362); 
				DebugLocation(45, 21);
				 value = q.Text.Substring(1,q.Text.Length-2);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// ./find/FindEval.g:46:4: v= UNQOTED_LITERAL
				{
				DebugLocation(46, 5);
				v=(CommonTree)Match(input,UNQOTED_LITERAL,Follow._UNQOTED_LITERAL_in_val371); 
				DebugLocation(46, 22);
				value =v.Text;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("val", 8);
			LeaveRule("val", 8);
			LeaveRule_val();
		}
		DebugLocation(46, 37);
		} finally { DebugExitRule(GrammarFileName, "val"); }
		return value;

	}
	// $ANTLR end "val"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expression_in_commandline48 = new BitSet(new ulong[]{0x25FA32UL});
		public static readonly BitSet _expr_in_expression60 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _other_in_expression69 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_expr88 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr92 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OR_in_expr106 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr110 = new BitSet(new ulong[]{0x25FA10UL});
		public static readonly BitSet _expr_in_expr114 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _AND_in_expr128 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr132 = new BitSet(new ulong[]{0x25FA10UL});
		public static readonly BitSet _expr_in_expr136 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _LPAREN_in_expr150 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expr_in_expr154 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _RPAREN_in_expr156 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NAME_in_expr170 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr172 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _val_in_expr176 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _INAME_in_expr189 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr191 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _val_in_expr195 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _REGEX_in_expr207 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr209 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _val_in_expr213 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IREGEX_in_expr225 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr227 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _val_in_expr231 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SIZE_in_expr242 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr244 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _integer_in_expr248 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _sizepostfix_in_expr252 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TYPE_in_expr263 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_expr265 = new BitSet(new ulong[]{0x6000000UL});
		public static readonly BitSet _type_in_expr269 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DEPTH_in_other283 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EQ_in_other285 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _integer_in_other289 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SIZEPOSTFIX_in_sizepostfix307 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INTEGER_in_integer324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_type341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_val362 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _UNQOTED_LITERAL_in_val371 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  find 
