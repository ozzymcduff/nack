//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 .\\find\\SearchExpr.g 2012-12-27 13:45:21

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  find 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class SearchExprParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "MATCH", "QUESTION", "STAR"
	};
	public const int EOF=-1;
	public const int MATCH=4;
	public const int QUESTION=5;
	public const int STAR=6;

	public SearchExprParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SearchExprParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return SearchExprParser.tokenNames; } }
	public override string GrammarFileName { get { return ".\\find\\SearchExpr.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_search();
	partial void LeaveRule_search();
	// $ANTLR start "search"
	// .\\find\\SearchExpr.g:14:1: search : ( match )* ;
	[GrammarRule("search")]
	private void search()
	{
		EnterRule_search();
		EnterRule("search", 1);
		TraceIn("search", 1);
		try { DebugEnterRule(GrammarFileName, "search");
		DebugLocation(14, 11);
		try
		{
			// .\\find\\SearchExpr.g:15:2: ( ( match )* )
			DebugEnterAlt(1);
			// .\\find\\SearchExpr.g:15:4: ( match )*
			{
			DebugLocation(15, 4);
			// .\\find\\SearchExpr.g:15:4: ( match )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=MATCH && LA1_1<=STAR)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// .\\find\\SearchExpr.g:15:5: match
					{
					DebugLocation(15, 5);
					PushFollow(Follow._match_in_search51);
					match();
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("search", 1);
			LeaveRule("search", 1);
			LeaveRule_search();
		}
		DebugLocation(15, 11);
		} finally { DebugExitRule(GrammarFileName, "search"); }
		return;

	}
	// $ANTLR end "search"

	partial void EnterRule_match();
	partial void LeaveRule_match();
	// $ANTLR start "match"
	// .\\find\\SearchExpr.g:16:1: match : ( STAR | QUESTION | MATCH );
	[GrammarRule("match")]
	private void match()
	{
		EnterRule_match();
		EnterRule("match", 2);
		TraceIn("match", 2);
		IToken MATCH1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "match");
		DebugLocation(16, 36);
		try
		{
			// .\\find\\SearchExpr.g:17:2: ( STAR | QUESTION | MATCH )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case STAR:
				{
				alt2 = 1;
				}
				break;
			case QUESTION:
				{
				alt2 = 2;
				}
				break;
			case MATCH:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// .\\find\\SearchExpr.g:17:4: STAR
				{
				DebugLocation(17, 4);
				Match(input,STAR,Follow._STAR_in_match61); 
				DebugLocation(17, 9);
				Emit(".*");

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// .\\find\\SearchExpr.g:18:4: QUESTION
				{
				DebugLocation(18, 4);
				Match(input,QUESTION,Follow._QUESTION_in_match68); 
				DebugLocation(18, 13);
				Emit(".");

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// .\\find\\SearchExpr.g:19:4: MATCH
				{
				DebugLocation(19, 4);
				MATCH1=(IToken)Match(input,MATCH,Follow._MATCH_in_match75); 
				DebugLocation(19, 10);
				EmitEscaped((MATCH1!=null?MATCH1.Text:null));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("match", 2);
			LeaveRule("match", 2);
			LeaveRule_match();
		}
		DebugLocation(19, 36);
		} finally { DebugExitRule(GrammarFileName, "match"); }
		return;

	}
	// $ANTLR end "match"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _match_in_search51 = new BitSet(new ulong[]{0x72UL});
		public static readonly BitSet _STAR_in_match61 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _QUESTION_in_match68 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MATCH_in_match75 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  find 
